## 15.1 메시지는 컨테이너, 엔터티는 화물


HTTP 메시지는 인터넷 운송 시스템의 컨테이너라고 생각한다면, 엔터티는 실질적인 화물이다

HTTP/1.1은 다음과 같이 10가지 주요 엔터티 헤더 필드를 정의한다
- **Content-Type:** 엔터티에 의해 전달된 객체의 종류
- **Content-Length**: 전달되는 메시지의 길이나 크기
- **Content-Language**: 전달되는 객체와 가장 잘 대응되는 자연어
- **Content-Encoding**: 객체 데이터에 대해 행해진 변형(압축 등)
- **Content-Location**: 요청 시점을 기준으로, 객체의 또 다른 위치
- **Content-Range**: 만약 이 엔터티가 부분 엔터티라면, 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의한다
- **Content-MD5**: 엔터티 본문의 콘텐츠에 대한 체크섬
- **Last-Modified**: 서버에서 이 콘텐츠가 생성 혹은 수정된 날짜
- **Expires**: 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되는 날짜
- **Allow**: 이 리소스에 대해 어떤 요청 메서드가 허용되는 지 (ex. GET, POST …)
- **ETag**: 인스턴스에 대한 고유한 검사기
- **Cache-Control**: 어떻게 문서가 캐시될 수 있는지에 대해 지시자


### 15.1.1 엔터티 본문

엔터티 본문은 가공되지 않는 데이터만을 담고 있고, 다른 정보들은 모두 헤더에 담겨 있다

엔터티 헤더는 본문의 데이터에 대한 의미를 설명한다

---

## 15.2 Content-Length: 엔터티의 길이

메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다

Content-Length 헤더는 메시지를 청크 인코딩으로 전송하지 않은 이상, 엔터티 본문을 포함한 메시지에서는 필수적으로 있어야 한다

서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때, 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요하다


### 15.2.1 잘림 검출

Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌것인지 서버가 충돌한 것인지 구분하지 못한다

메시지 잘림은 캐싱 프락시 서버에서 취약한데, 캐시가 잘린 메시지를 수신했지만 잘렸다는것을 인식하지 못하면, 결함있는 콘텐츠를 계속 제공하게 된다

따라서 명시적으로 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보통 캐시하지 않는다


### 15.2.2 잘못된 Content-Length

Content-Length가 잘못된 값을 담고 있을 경우, 아예 빠진것보다도 큰 피해를 유발할 수 있다

공식적으로 HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 인지했을 때 사용자에게 알려주게 되어 있다


### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)

응답이 지속 커넥션을 통해서 온 것이면, 또 다른 HTTP 응답이 그 뒤를 잇는다

Content-Length 헤더는 메시지 하나가 어디서 끝나고 다른 시작은 어디인지 알려준다

커넥션이 지속적이기 때문에, 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능하기 때문에, Content-Length 헤더가 필요하다

Content-Length 헤더 없이 지속 커넥션을 만나는 경우가 있는데, 청크 인코딩을 사용할 때이다

청크 인코딩은 데이터가 각각 특정 크기를 가지게 되며, 서버가 엔터티 전체의 크기를 알수 없다고 하더라도, 정의된 크기만큼의 조각들로 보내기 때문이다


### 15.2.4 콘텐츠 인코딩

HTTP는 보안을 강화하거나 압축을 위해 공간을 절약할 수 있도로고, 엔터티 본문을 인코딩할 수 있게 해준다

만약 인코딩된 경우, Content-Length는 인코딩된 본문의 길이를 표현한다


### 15.2.5 엔터티 본문 길이 판별을 위한 규칙
1.  본문을 갖는 것이 허용되지 않는 특정 HTTP 메시지에서는 Content-Length가 무시된다 이 경우 Content-Length 헤더는 부가정보에 불과하며, 실제 본문 길이를 서술하지 않는다 가장 중요한 예는 HEAD 응답으로, GET 요청과 동일한 응답을 보내지만 본문만 보내지 않는다 따라서 Content-Length 헤더를 갖지만 본문을 갖지 않으며, 이와 같이 본문을 금하는 메시지의는 헤더 이후 빈줄에서 끝나야 한다
2.  메시지가 Transfer-Encoding 헤더를 포함하고 있다면, 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 ‘0바이트 청크’라 불리는 패턴으로 끝나야 한다
3.  메시지가 Content-Length 헤더를 갖고, Transfer-Encoding 헤더가 존재하지 않는다면, Content-Length 값은 본문의 길이를 담게 된다 만약 Content-Length 헤더 필드와 Transfer-Encoding 헤더 필드를 갖고 있는 메시지를 Content-Length rkqtdms 받았다면 무시해야 한다
4.  메시지가 ‘multiplart/byteranges’ 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분을 각자가 스스로의 크기를 정의할 것이다 해당 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 본문 유형이다
5.  위의 어떤 규칙에도 해당되지 않는다면 서버가 메시지를 끝났음을 알려줄 때에 커넥션이 끊기는데, 그 때에 엔터티는 끝난다
6.  HTTP/1.0 애플리케이션과의 호환을 위해, 본문을 갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 한다

---

## 15.3 엔터티 요약

HTTP가 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 불구하고, 여러 이유로 메시지의 일부분이 전송 중 변형되는 일이 생긴다

본문 데이터에 의도치 않은 변경을 감지하기 위해, 송신자는 체크섬을 생성하고 수신자는 체크섬을 검사할 수 있다

Content-MD5 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용된다

응답을 처음 만든 서버만 Content-MD5 헤더를 계산해서 보내고, 프락시와 캐시는 해당 헤더를 변경하거나 추가하지 않아야 한다

무결성을 위함으로 클라이언트에서 무결성을 검증하기 위해서는 전송 인코딩을 디코딩 한 후에, 디코딩된 엔터티 본문에 대해 MD5를 계산해야 한다

MD5는 무결성 검사 뿐만 아니라 문서의 위치를 빠르게 알아내고 콘텐츠 중복 저장을 방지하기 위한 키로서 이용될 수 있다

하지만 Content-MD5는 자주 전송되지 않는다

HTTP 확장들은 다른 요약 알고리즘을 제안하며, 클라이언트가 응답에 대해 기대하는 요약유형을 전달하는 역할인 새로운 헤더로 Want-Digest를 제안했다

해당 헤더에 quality value을 이용해 여러 요약 알고리즘을 제안하고 선호도를 지정해줄 수 있다

---

## 15.4 미디어 타입과 차셋 (Charset)

Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다

MIME 타입은 전달되는 데이터 매체의 기저 형식의 표준화된 이름으로, 클라이언트에서 콘텐츠를 적절히 해독하기 위해 사용한다

Content-Type의 값은 인터넷 할당 번호 관리기관에 등록된 표준화된 MIME 타입이다

주 미디어 타입으로 시작해서 뒤이어 빗금, 그리고 미디어 타입을 더 구체적으로 서술하는 부 타입으로 구성된다
-   text/html, text/plain
-   image/gif, image/jpeg
-   audio/x-wav
-   model/vrml
-   application/vnd.ms-powerpoint
-   mulitiplart/byteranges
-   message/http


### 15.4.1 텍스트 매체를 위한 문자 인코딩

Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원한다

웬터티의 비트 집합을 텍스트 파일 글자들로 변환하기 위한 ‘charset’ 매개변수가 대표적인 예이다


### 15.4.2 멀티파트 미디어 타입

MIME ‘멀티파트' 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다

HTTP는 멀티파트 본문도 지원하는데, 폼을 채워서 제출할 때와 문서의 일부분을 보내는 범위 응답을 할 때만 사용한다


### 15.4.3 멀티파트 폼 제출

HTTP 폼을 채워서 제출하면, 가변 길이 텍스트와 업로드 될 객체는 각각 하나의 파트로서 멀티파트 본문을 구성하여 보내게 된다

이러한 요청을 Content-Type: multiplart/form-data 나 Content-Type: multiplart/mixed 헤더와 함께 보낸다


### 15.4.4 멀티파트 범위 응답

범위 요청에 대한 HTTP 응답도 멀티파트가 되는데, Content-Type: multiplart/byteranges 헤더 및 범위를 담고 있는 멀티 파트 본문이 함께 온다

---

## 15.5 콘텐츠 인코딩


### 15.5.1 콘텐츠 인코딩 과정
1.  웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다
2.  콘텐츠 인코딩 서버가 인코딩 된 메시지를 생성한다. 인코딩 된 메시지는 Content-Length 가 달라지고, Content-Encoding 을 추가한다
3.  수신 측에서 디코딩하여 원본을 얻는다


### 15.5.2 콘텐츠 인코딩 유형

HTTP는 몇 가지 표준 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다

인코딩은 각 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화된다

흔히 쓰이는 몇가지 콘텐츠 인코딩 토큰이다
-   gzip: GNU zip 인코딩이 적용되었음을 의미한다
-   compress: 유닉스 파일 압축 프로그램 compress가 실행되었음을 의미한다
-   deflate: zlib 포맷으로 압축되었음을 의미한다
-   identity: 어떤 인코딩되 수행되지 않았음을 의미한다

그 중, gzip이 일반적으로 가장 효율적이고 널리 쓰이는 압축 알고리즘이다


### 15.5.3 Accept-Encoding 헤더

클라이언트가 해독할 수 있는 방법으로 서버에게 인코딩할 것을 요청하기 위해, 클라이언트 자신이 지원하는 인코딩 목록을 Accept-Encoding 헤더를 통해 전달한다

만약 해당 헤더가 없을 경우, 어떤 인코딩도 받아들일 수 있다는 것으로 간주한다

또한 인코딩에 Q(quality)값을 매개변수로 더해 선호도를 나타낼 수 있으며, 0~1 까지의 값을 가진다

---

## 15.6 전송 인코딩과 청크 인코딩

콘텐츠 인코딩은 콘텐츠 포맷과 긴밀하게 연관되어 있는데, 텍스트 파일과 JPEG 파일은 각각 압축이 되지 않는 인코딩 형식이 있기 때문이다

전송 인코딩은 콘텐츠 포맷과 독립적으로 작동한다는 점에서 콘텐츠 인코딩과 다르다


### 15.6.1 안전한 전송

전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 ‘안전한 전송'을 위해 존재했으며, 지금의 안정적인 HTTP는 전송 인코딩을 다른 목적을 위해 사용하고 있다

HTTP 에서 전송된 메시지 본문에 문제가 있는 경우는 몇 가지 없다

**알 수 없는 크기**
- 콘텐츠의 모든 크기를 다 알기도 전에 메시지를 전송하려고 할 경우, HTTP는 Content-Length를 요구하는 문제가 생긴다
- 몇몇 서버는 데이터 끝을 알리는 특별한 꼬리말을 포함시켜 전송 인코딩으로 데이터를 보내려 시도한다

**보안**
- 공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞어버리는 방법이 있다
- 하지만 SSL과 같은 전송 계층 보안 방식이 있기 때문에 전송 인코딩 보안은 흔하지 않다


### 15.6.2 Transfer-Encoding 헤더

전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 두개이다

**Transfer-Encoding**
- 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 서버가 수신자에게 알려준다

**TE**
- 클라이언트에서 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용한다

Accept-Encoding 과 마찬가지로 선호도에 따른 Q값을 가질 수 있다

하지만 HTTP/1.1 에서는 0 값을 가지는 것을 금지한다


### 15.6.3 청크 인코딩

청크 인코딩은 메시지를 일정 크기의 청크로 나누어, 순차적으로 전송한다

청크 인코딩을 이용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어지고, 동적으로 본문을 생성하면서 조금씩 버퍼에 담아 청크를 만들어 바로 보내면서 반복한다

청크 인코딩은 전송 인코딩 방식이며, 본문이 아닌 메시지의 속성이다

**청크와 지속 커넥션**
- 클라이언트와 서버 사이의 커넥션이 지속적이지 않다면, 자신이 읽고 있는 본문의 크기를 알 필요가 없으며, 서버가 커넥션을 닫을때까지 본문으로 간주하고 읽을 것이다
- 지속 커넥션에서는, 반드시 Content-Length 헤더에 본문의 길이를 담아줘야 하는데, 만약 콘텐츠가 동적으로 생성된다면, 보내기 전에 길이를 아는 것은 불가능하다
- 청크 인코딩을 통해서 이에 대한 딜레마를 해결할 수 있게 준다.
- 모든 청크들을 지속해서 보내면서, 마지막에 크기가 0인 청크로 본문이 끝났음을 알리고, 다음 응답을 위해 커넥션을 계속 유지할 수 있게 된다
- 청크 인코딩는 길이 값과 각 청크에 대한 데이터를 담고 있으며, 청크 길이 값은 16진수로 되어 있고, 청크 데이터와 CRLF로 분리된다
- 클라이언트도 청크 인코딩된 데이터를 서버로 전송하는데, 서버가 청크 인코딩을 받을지 모르기때문에 청크 요청 거부에 대한 대비가 필요하다

**청크 인코딩된 메시지의 트레일러**
- 두가지 중 하나 이상 조건을 만족하면 청크 메시지에 트레일러를 추가할 수 있다
	- 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
	- 트레일러의 콘텐츠가 클라이언트에서 이해하고 사용할 필요 없는 선택적인 메타데이터이므로 무시하고 버려도 되는 경우
- 트레일러에는 본문의 콘텐츠가 먼저 생성되어야 한다거나 하는 등의 이유로 메시지 시작 시점에서 값을 알수 없는 추가적인 헤더 필드를 담을 수 있다
- 트레일러로 보낼 수 있는 헤더의 예로 Content-MD5 헤더가 있다


### 15.6.4 콘텐츠와 전송 인코딩의 조합

콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다

또한 전송된 메시지들은 반대로 재구축하는 절차를 통해 원문으로 되돌린다


### 15.6.5 전송 인코딩 규칙

전송 인코딩이 적용될 때, 몇 가지 규칙이 적용되어야 한다
-   전송 인코딩의 집합은 반드시 ‘chunked’를 포함해야 하는데, 예외로는 메시지가 커넥션의 종료로 끝나는 경우 뿐이다
-   청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다
-   청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다

전송 인코딩은 HTTP/1.1 에서 소개된 비교적 새로운 기능이다

전송 인코딩을 구현한 서버는 비 HTTP/1.1 애플리케이션에 전송 인코딩된 메시지를 보내지 않도록 주의해야 하며, 반대로도 마찬가지 이다

---

## 15.7 시간에 따라 바뀌는 인스턴스

웹 객체는 정적이지 않으며, 같은 URL도 시간에 따라 다른 버전의 객체를 가리킬 수 있다

HTTP 프로토콜은 특정한 종류의 요청이나 응답을 다루는 방법들을 정의하는데, 이를 인스턴스 조작이라고 불리며, 객체의 인스턴스에 작용한다

대표적인 두 가지가 범위 요청, 델타 인코딩 이다

두 가지 모두, 클라이언트가 갖고 있는 리소스의 사본이 서버의 리소스와 동일한 지 판단하고, 상황에 따라 새 인스턴스를 요청할 수 있는 능력을 가져야 한다

---

## 15.8 검사기와 신선도

일단 문서가 클라이언트에서 만료되면, 서버에서 최신 사본을 요구해야 한다

만약 서버에서도 문서가 변경되지 않았다면, 다시 받을 필요 없이 갖고 있던 캐시된 사본을 사용하면 된다

조건부 요청이라고 불리는 해당 요청은, 클라이언트에게 자신이 갖고 있는 버전을 말해주고, 사본이 유효하지 않을 때만 새로 보내달라는 요청이다


### 15.8.1 신선도

서버는 콘텐츠의 캐시 기간을 정하여 언제까지 신선하다고 판단할지에 대한 정보를 줄 것이다

이는 Expires, Cache-Control 헤더를 통해 알 수 있다

Expires 헤더는 만료되는 정확한 날짜를 명시한다

Expires 헤더를 바르게 사용하는 클라이언트나 헤더는, 시계를 반드시 동기화 시켜야 하는데 쉽지 않다

같은 시계 동기화 프로토콜을 실행하지 않을 가능성이 있기 때문이다

따라서 상대시간을 이용해 만료를 정의하는 매커니즘이 더 쓸만하며, Cache-Control 헤더는 문서가 서버를 떠난 후로부터의 초 단위로 정하게 된다

수명은 시계 동기화와 의존하지 않기 때문에 더 정확한 결괄르 말해줄 수 있다


### 15.8.2 조건부 요청과 검사기

캐시의 사본이 요청되었을 때, 신선하지 않으면 사본을 바꾸어야 한다

캐시는 원 서버에서 현 시점의 사본을 가져올 수 있지만, 대개 서버에 있는 문서는 캐시에 들어있는 신선하지 않은 사본과 같을 것이다

만약 캐시된 문서가 만료되어 바꾸어야 할 때, 내용이 동일하다면 결국 여러 리소스에 대해 낭비가 발생한다

이를 고치기 위해 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라는 특별한 요청이 존재한다

조건부 요청은 ‘If-’로 시작하는 조건부 헤더에 의해 구현되며, 조건이 참이 아니라면 에러코드를 반환하게 된다

각 조건부 요청은 특정 검사기 위해서 동작하는데, 검사기는 문서의 테스트된 특정 속성(일련번호, 버전 번혹, 최종 변경일 …)이다

HTTP는 검사기를 약한 검사기와 강한 검사기 두 가지로 분류한다

약한 검사기는 리소스의 인스턴스를 고유하기 식별하지 못하는 경우도 있다

강한 검사기는 언제나 고유하게 식별한다

최종 변경 시각은 약한 검사기로 간주되는데, 정확도가 최대 1초이기 때문이며, 리소스는 1초 안에 여러 번 변경될 수 있기 때문이다

ETag 헤더는 강한 검사기로 간주되며, 매 변경마다 구분되는 값이 정해지기 대문이다

클라이언트와 서버는 때때로 엔터티 태그 검사를 통과하지 못한 버전을 채택하는 경우가 있다

예를 들어, 크고 자주 찾는 캐시된 문서에 대해, 캐시 재검사로 인해 대량 전송을 유발하지 않으면서 겉모양만 살짝 바꾸고 싶을 경우, ‘W/’를 태그 앞에 붙여 약한 엔터티임을 알린다

---

## 15.9 범위 요청

HTTP는 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다

만약 무언가를 다운받을 때 중간에 끊겼을 경우, 다시 처음부터 시작해야 한다

범위 요청을 이용하면, 받다가 실패한 엔터티를 일부 혹은 범위로 요청하여, 중단된 시점에서 재개할 수 있게 된다

Range 헤더를 통해 여러 범위를 요청하기 위해 사용할 수 있다

서버는 클라이언트에게 자신이 범위를 받아들일 수 있는지 알려주기 위해 Accept-Range를 포함시켜 알려준다

---

## 15.10 델타 인코딩

새로운 페이지 전체를 보내는 대신에, 클라이언트 사본에 대해 변경된 부분만 서버가 보내면 더 빨리 페이지를 얻을 수 있게 된다

델타 인코딩은 변경된 부분만 통신하여 전송량을 최적화하는 HTTP 확장이다

클라이언트는 어떤 버전의 페이지를 가지고 있는지 서버에게 말해줘야 하는데, 이는 최신 버전에 대한 변경 부분만 받아들일 의사가 있음을 말한다

그리고 버전뿐만 아니라, 변경부분(델타)를 적용하기 위해 어떤 알고리즘을 알고 있는지도 서버에게 말해야 한다

서버는 자신이 클라이언트가 갖고 있는 버전을 갖고 있는지, 그리고 어떻게 델타를 계산할 것인지 체크해야 한다

그 뒤에는 델타를 계산하여 클라이언트에게 보내주고, 서버가 델타를 보내고 있다는 것을 클라이언트에게 알려준 뒤, 페이지의 최신 버전에 대한 새 식별자를 명시해야 한다

클라이언트는 자신이 갖고 있는 버전에 대한 유일한 식별자를 If-None-Match 헤더에 담는다

서버에서는 식별자가 다를 경우, 페이지 전체를 보내게 된다

클라이언트가 서버에게 A-IM 헤더를 보내어 자신이 페이지에 대한 델타를 받아들일 수 있음을 알려준다

A-IM는 Accept-Instance-Manipulation 의 줄임말이다

클라이언트는 페이지의 예전 버전과 델타를 이용해 최신 버전의 문서를 생성하는 방법에 대한 자신이 알고있는 알고리즘을 A-IM 헤더 안에 명시한다

서버는 인스턴스 조작을 보내고 있음을 말해주는 226 응답코드, 델타 계산을 위한 알고리즘을 명시한 IM 헤더, 새 ETag 헤더, 그리고 델타를 계산할 때 기반이 된 문서 ETag를 지정한 Delta-Base 헤더를 돌려준다


### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기

클라이언트는 A-IM 헤더를 사용해서 자신이 받아들일 수 있는 인스턴스 조작의 종류를 명시할 수 있고, 서버는 IM 헤더에 사용한 인스턴스 조작의 종류를 명시할 수 있다

아래는 IANA에 등록된 인스턴스 조작의 종류 몇가지이다
-   vcdiff: vcdiff 알고리즘을 이용한 델타
-   diffe: 유닉스 diff -e 명령을 이용한 델타
-   gdiff: gdiff 알고리즘을 이용한 델타
-   gzip: gzip 알고리즘을 이용한 압축
-   deflate: deflate 알고리즘을 이용한 압축
-   range: 현재 응답이 범위 선택에 대한 결과인 부분 컨텐츠임을 알려주기 위해 서버 응답에서 사용
-   identit: 클라이언트가 identity 인스턴스 조작을 받아들일 의사가 있음을 말해주기 위해 클라이언트 요청의 I-AM 헤더에서 사용

서버의 ‘델타 생성기'는 기저 문서와 그 문서의 최신 인스턴스를 취하여, 클라이언트 A-IM 헤더에 지정된 알고리즘을 사용해 둘 사이 델타를 계산한다

클라이언트 측에서는, ‘델타 적용기'가 델타를 취하여 기저 문서에 적용시켜 문서의 최신 인스턴스를 생성한다

A-IM과 IM헤더의 포맷은 여러번 지정될 수 있다

압축을 극대화하기 위해 여러번의 인스턴스 조작을 거칠 수 있다는 말로, 그에 따른 적절한 방식을 취해야 한다

델타 인코딩은 전송 시간을 줄일 순 있지만, 구현하기가 까다롭다는 단점이 있다

변경이 잦고 많은 사람들이 접근할 경우, 서버는 자신이 제공하는 페이지가 변경될때마다 사본을 가지고 있어야 한다

문서를 제공하는데에 걸리는 시간이 줄어들지만, 문서의 과거 사본을 유지하기 위해 디스크 공간이 늘어나야 하며, 전송량 감소로 얻은 이득이 무의미해지게 된다
