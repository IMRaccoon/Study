콘텐츠 리소스를 저장, 중개, 관리하는 일을 통틀어 웹 호스팅이라고 한다

콘텐츠를 저장해서 제공하고 관련 로그들을 접근하거나 관리하는 데 서버가 필요하다

## 18.1 호스팅 서비스

서버실을 짓고 도메인 이름을 등록하고 네트워크 대역복을 구매할 금액과 시간이 없다

따라서 이를 전문적으로 관리해주는 새로운 신사업들이 만들어졌다

### 18.1.1 간단한 예 : 전용 호스팅

ISP 업체는 대량으로 서버 장비를 구매할 수 있으며, 안정적이고 검증되었고 저렵한 장비를 선택할 수 있다

따라서 사용자들은 ISP 업체들을 통해 서버를 받아 서비스를 제공할 수 있다

## 18.2 가상 호스팅

트래픽이 낮은 사이트에 많은 비용이 드는 전용 서버를 제공하는 것은 낭비이다

따라서 컴퓨터 한 대를 여러 고객이 공유하게 해서 저렴한 웹 호스팅 서비스를 제공한다

-   이를 가상호스팅이라고 부른다
-   다른 서버에서 호스팅하는 것처럼 보이지만, 물리적으로는 동일한 서버에서 호스팅 된다
-   사용자의 관점에서는 물리적으로 분리된 전용 서버와 구분을 못해야 한다

가상 호스팅이 이점이 있기 때문에, 업체에서는 한 서버에 많은 웹 사이트를 호스팅하려 한다

-   하지만 실제로 한 서버에 수백개의 웹 사이트를 구축한다는 것은 아니다
-   서버팜이라 불리는 복제 서버 더미를 만들고 부하를 분산할 수 있다

### 18.2.1 호스트 정보가 없는 가상 서버 요청

HTTP/1.0 명세는 공용 웹서버의 가상 웹 사이트에 누가 접근하고 있는지 식별하는 기능이 없다

-   여러 도메인에 같은 경로를 요청할 경우, 도메인을 제외하기 때문에 식별이 불가능하다
-   웹 사이트 호스트 정보가 요청에서 제거된다

### 18.2.2 가상 호스팅 동작하게 하기

초기 명세는 가상 호스팅을 고려하지 않았기 때문에, 공용 가상 호스팅을 지원하기 위해 개발해야 했다

-   HTTP 요청 메시지에 완전한 URL도 포함하여 간단히 해결 할 수 있다
-   하지만 모든 애플리케이션에 해당 명세를 맞추기 위해서는 시간이 오래 걸린다
-   따라서 이를 위해 네 가지의 기술이 나타났다

**_URL 경로를 통한 가상 호스팅_**

-   각 가상 사이트에 서로 다른 URL 경로를 할당해서 각각을 강제로 구분할 수 있다
    -   예를 들면 GET /index.html 이 아닌 GET/a/index.html로 바꾸게 한다
-   하지만 접두어는 불필요하고 혼란스러우며, 일반적인 메인페이지 방식이 동작하지 않는다

**_포트번호를 통한 가상호스팅_**

-   각각의 가상 웹사이트에 포트번호를 할당한다
-   하지만 URL에 비표준 포트를 쓰지 않고서도 리소스를 찾길 원한다

**_IP 주소를 통한 가상 호스팅_**

-   각 가상 웹 사이트에 유일한 IP 주소를 한 개 이상 부여한다
-   서버는 HTTP 커넥션의 목적지 IP 주소를 보고 클라이언트가 어떤 웹 사이트를 연결하려는지 알 수 있다
-   가상 IP 호스팅은 잘 동작하지만, 규모가 아주 클 경우 문제가 생긴다
    -   일반적으로 장비의 IP 개수에는 제한이 있다
    -   IP 주소는 희소 상품으로, 호스팅 업자가 충분히 IP 주소를 얻지 못할 수 있다
    -   호스팅 업자의 서버 복제로 인해, 각 복제된 서버에 IP 주소를 부여해야 하므로 늘어난 만큼 필요해진다

**_Host 헤더를 통한 가상 호스팅_**

-   IP 주소의 낭비와 가상 IP 제한 문제를 피하려면, 같은 IP를 사용해도 어디에 속해있는지 알아야 한다
-   이를 해결하기 위해 모든 요청에 호스트명과 포트를 Host 확장 헤더에 기술해서 전달한다
-   HTTP/1.0을 확장한 HTTP/1.0+에서 처음 소개되었으며, HTTP/1.1 명세를 따르기 위해서는 Host 헤더를 써야한다

### 18.2.3 HTTP/1.1 Host 헤더

가상 서버는 흔하기 때문에 대부분의 클라이언트가 HTTP/1.1과 호환되지 않더라도, Host 헤더는 구현한다

**_문법과 사용 방법_**

-   Host 헤더에는 원본 URL에 있는 요청 리소스에 대한 호스트와 포트번호를 기술한다
    -   Host = `Host : 호스트[:포트]`
-   그리고 아래의 규칙들이 있다
    -   Host 헤더에 포트가 기술되어 있지 않으면, 해당 스킴의 기본 포트를 사용한다
    -   URL에 IP주소(또는 호스트명)가 있으면, Host 헤더는 같은 주소(호스트명)를 포함해야 한다
    -   URL에 호스트명이 기술되어 있으면 헤더는 IP 주소를 포함하지 않아야 한다
    -   클라이언트가 특정 프락시를 사용한다면, 헤더에 원 서버의 호스트명과 포트를 기술해야 한다
    -   클라이언트는 모든 요청에 Host 헤더를 기술해야 하며, 웹 프락시는 요청 메시지에 Host 헤더를 추가해야 한다

**_Host 헤더의 누락_**

-   만약 Host 헤더를 사용해야 하는데 없는 경우, 기본 웹페이지로 보내거나 에러 페이지를 반환한다

**_Host 헤더 해석하기_**

-   호스트를 기준으로 리소스를 구분하는 모든 웹서버는 HTTP/1.1을 통해 오는 리소스를 결정하려면 아래의 규칙을 사용해야 한다
    1. HTTP 요청 메시지에 전체 URL이 기술되어 있으면, Host 헤더에 있는 값을 무시하고 URL을 사용한다
    2. HTTP 요청 메시지에 있는 URL에 호스트명이 기술되어 있지 않고, Host 헤더에만 있다면 이를 사용한다
    3. 1, 2단계에서 호스트를 결정할 수 없드면 400 응답을 반환한다

**_Host 헤더와 프락시_**

-   어떤 브라우저 버전은 부정확한 Host 헤더를 보내는데, 프락시를 사용하게 설정했을 때 특히 그렇다

## 18.3 안정적인 웹 사이트 만들기

### 18.3.1 미러링 된 서버 팜

서버 팜은 서로 대신할 수 있고 식별할 수 있게 설정된 웹 서버의 집합이다

-   한 곳에 문제가 생기면 다른 한 곳에서 대신 전달할 수 있게 미러링 할 수 있다

미러링 된 서버는 계층적인 관계에 있다

-   원본 콘텐츠를 가지고 있는 서버는 마스터 원 서버라 불린다
-   마스터 원 서버로부터 콘텐츠를 받은 미러링 된 서버는 복제 원 서버라 부른다
-   서버 팜에 배포하는 가장 간단한 방법은, 네트워크 스위치를 사용해 분산 요청을 보내는 것이다
-   외부에서는 스위치 IP를 통해 콘텐츠를 요청하고, 스위치에서는 서버들을 통해 요청을 전송한다

클라이언트의 요청이 특정 서버로 가는 두가지 방법이 있다

-   HTTP 리다이렉션
    -   콘텐츠에 대한 URL은 마스터 서버의 IP를 가리키고, 요청을 받은 직시 복제 서버로 리다이렉트 시킨다
-   DNS 리다이렉션
    -   콘텐츠의 URL은 복제 서버들의 IP 주소를 가리킬 수 있고, DNS 서버는 클라이언트에게 전송할 IP 주소를 선택할 수 있다

### 18.3.2 콘텐츠 분산 네트워크

콘텐츠 분산 네트워크(CDN)는 특정 콘텐츠의 분산을 목적으로 하는 단순한 네트워크이다
네트워크의 노드는 서버, 대리 서버, 혹은 프락시 서버가 될 수 있다

### 18.3.3 CDN의 대리 캐시

대리 캐시는 복제 원 서버를 대신해 사용될 수 있다

-   리버스 프락시라고도 불리는데, 미러링 된 웹 서버처럼 콘텐츠에 대한 요청을 받는다
-   특정 원 서버 집합을 대신해 요청을 받게 된다

대리 서버와 미러링 서버의 차이점은, 대리 서버는 수요에 따라 동작한다는 차이이다

-   대리 서버는 전체 콘텐츠를 복사하지 않으며, 클라이언트가 요청하는 콘텐츠만 저장한다
-   원 서버는 콘텐츠를 업데이트 해줄 의무는 없으며, 사용자가 요청하기 전에 콘텐츠를 미리 가져오는 기능을 가진 대리 서버도 있다

### 18.3.4 CDN의 프락시 캐시

프락시 캐시는 대리 서버와 다르게, 어떤 웹 서버 요청이든 다 받을 수 있다

하지만 대리 서버를 사용하면, 프락시 캐시의 콘텐츠는 요청이 있을 때만 저장되고, 원본을 정확히 복제한다는 보장도 없다

요청이 있을 때만 저장하는 프락시 캐시는, 스위치나 라우터가 중간에서 웹 트래픽을 가로채 처리한다

## 18.4 웹 사이트 빠르게 만들기

서버 팜이나 분산 프락시 캐시나 대리 서버는 혼잡을 조절하고 네트워크 트래픽을 분산시킨다

콘텐츠를 분산시키면, 사용자에게 더 가까워지기 때문에 전송 시간이 단축된다
