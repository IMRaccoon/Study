## 7.1 불필요한 데이터 전송

복수의 클라이언트가 접근할 때, 서버는 같은 문서를 클라이언트들에게 각각 한 번씩 전송하게 된다

똑같은 바이트들이 네트워크를 통해 계속 반복해서 이동하는데, 값비싼 네트워크 대역폭을 잡아먹고, 부하를 준다

캐시를 이용하면, 첫번째 응답은 캐시에 보관하고, 뒤이은 동일한 요청들에 대해 응답으로 사용할 수 있다

---

## 7.2 대역폭 병목

많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다

클라이언트들이 서버에 접근할 때의 속도는 그 경로에 있는 가장 느린 네트워크의 속도와 같다

만약 WAN 네트워크가 아니라, LAN에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선할 수 있다

---

## 7.3 갑작스러운 요청 쇄도(Flash Crowds)

캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다

갑자기 많은 사람들이 거의 동시에 웹 문서에 접근할 때 초래된 불필요한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기시킨다

---

## 7.4 거리로 인한 지연

모든 네트워크 라우터는 각각 인터넷 트래픽을 지연시키며, 이로인해 거리도 문제가 된다

---

## 7.5 적중과 부적중

캐시가 세상 모든 문서의 사본을 저장하지는 않는다

캐시에 요청이 도착했을때 사본이 있으면 cache hit, 사본이 없으면 원 서버로 전달되며 cache miss라 부른다


### 7.5.1 재검사(Revalidation)

원 서버 콘텐츠는 변경될 수 있기 때문에 사본이 최신인지 때때로 점검해야 되며, 이러한 검사를 HTTP 재검사라 부른다

HTTP는 서버의 전체 객체를 가져오지 않고 여전히 최신인지 빠르게 검사할 수 있는 특별한 요청을 정의했다

캐시는 원할때마다 사본을 재검사 할 수 있지만, 캐시는 문서를 수백만개씩 가지고 있는 경우가 흔하고 네트워크 대역폭은 부족하다

따라서 검사할 만큼 오래된 경우에만 재검사를 한다

캐시된 사본의 재검사가 필요할 때, 원 서버에 재검사 요청을 보낸다

만약 변경되지 않았다면 원서버는 304 Not Modified 응답을 보내며, 캐시는 해당 사본을 최신이라고 표시한 다음 클라이언트에게 제공한다

이를 재검사 적중 또는 느린 적중이라고 부르며, 순수 캐시 적중보다 느리지만 캐시 부적중보다는 빠르다

HTTP는 캐시된 객체를 재확인하기 위한 몇 가지 도구를 제공하는데, 그 중에서 가장 많이 쓰이는 것은 If-Modified-Since 헤더다

서버에게 보내는 GET 요청에 해당 헤더를 추가하면 변경된 경우에만 사본을 보내달라는 의미가 된다

**재검사 적중**
- 만약 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 HTTP 304 응답을 보낸다

**재검사 부적중**
- 만약 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 응답을 클라이언트에게 보낸다

**객체 삭제**
- 만약 서버 객체가 삭제되었다면, 서버는 404 응답을 보내며, 캐시는 사본을 삭제한다


### 7.5.2 적중률

캐시가 요청을 처리하는 비율을 캐시 적중률라고 부르며 0~1까지의 값으로 되어 있으며 퍼센트로 표현되기도 한다

캐시 관리자는 적중률이 100%에 근접하게 되는것이 좋으며, 적중률은 예측하기 어렵지만 오늘날은 40%면 웹 캐시로 괜찮은 편이다

보통 크기의 캐시라도 자주 쓰이는 문서들을 보관하여 상당히 트래픽을 줄이고 성능을 개선할 수 있다


### 7.5.3 바이트 적중률

문서들이 모두 같은 크기인 것은 아니기 때문에 적중률이 모든 것을 말해주지 않는다

몇몇 큰 객체는 덜 접근되지만 크기 때문에 전체 트래픽에는 더 크게 기여한다

따라서 몇몇 사람들은 바이트 단위 적중률 측정값을 더 선호한다

바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다

문서 적중률을 개선하면 트랜잭션의 고정 소요시간이 줄어들어 전체 대기시간(지연)이 줄어든다

바이트 단위 적중률은 바이트가 인터넷으로 나가지 않기 때문에 대역폭 절약을 최적화한다


### 7.5.4 적중과 부적중의 구별

HTTP는 클라이언트에게 응답이 캐시 적중이었는지 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다

두 경우의 응답은 본문을 갖고 있는 HTTP 200가 된다

어떤 상용 프락시 캐시는 캐시에 무슨 일이 일어났는지 설명하기 위해 Via 헤더에 추가정보를 붙인다

클라이언트가 응답이 캐시에서 알아보는 방법은 Date헤더를 사용하는 것이다

Date 헤더 값을 현재 시각과 비교하여, 응답의 생성일이 더 오래되었다면 캐시된 것임을 알 수 있다

또는 응답이 얼마나 오래되었는지 말해주는 Age 헤더를 이용한다

---

## 7.6 캐시 토폴로지


### 7.6.1 개인 전용 캐시

개인 전용 캐시는 많은 에너지나 저장 공간을 필요로 하지 않고, 작고 저렴하다

웹 브라우저는 개인 전용 캐시를 내장하고 있으며, 자주 쓰이는 문서를 개인용 컴퓨터의 디스카와 메모리에 캐시해놓고, 캐시 사이즈와 설정을 수정할 수 있도록 허용한다

캐시에 어떤 것들이 들어있는지 확인하기 위해 브라우저 안을 들여다보는 것도 가능하다


### 7.6.2 공용 프락시 캐시

공용 캐시는 흔히 프락시 캐시라고 불리는 공유된 프락시 서버이며 로컬 캐시에서 문서를 제공하거나, 사용자 입장에서 서버에 접근한다

여러 개인 전용 캐시들에서 제각각 원 서버에 같은 문서를 접근하는것은 비효율적이며, 공용 캐시에서 자주 찾는 객체를 한번만 가져와서 개인 전용 캐시들에게서 요청받은 사본을 제공하여 트래픽을 줄인다

공용 프락시 캐시는 이전 6장에서 서술한 것처럼, 프락시 규칙을 따른다

수동 프락시를 지정하거나 프락시 자동설정 파일을 설정하여 브라우저가 프락시 캐시를 사용하도록 설정할 수 있다

또한 인터셉트 프락시를 사용함으로써 브라우저 설정 없이 HTTP 요청이 캐시를 통하도록 강제할 수 있다


### 7.6.3 프락시 캐시 계층들

작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적인 경우가 많다

클라이언트 주위에는 작고 저렴한 캐시를 사용하고, 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하는 큰 캐시를 사용하는 방식이다

대부분 사용자들이 가까운 1단계 캐시에서 적중하면 좋지만, 그렇지 않으면 큰 부모 캐시가 요청을 처리할 수 있다

하지만 프락시 연쇄가 길어질수록 각 중간 프락시는 현저한 성능저하가 발생한다


### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

몇몇 네트워크 아키텍처는 복잡한 캐시망을 만든다

캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지, 아니면 요청이 원 서버로 바로 가도록 할 것인지에 대한 캐시 커뮤니케이션 결정을 동적으로 내린다
- URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택한다
- URL에 근거하여 특정 부모 캐시를 동적으로 선택한다
- 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아본다
- 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 transit은 허용하지 않는다

이러한 복잡한 캐시 사이의 관계는 서로 다른 조직들이 이득을 위해 서로 캐시를 연결하여 찾아볼 수 있게 해준다

선택적인 피어링을 지원하는 캐시는 형제 캐시라고 불린다

HTTP는 형제 캐시를 지원하지 않기 때문에 인터넷 캐시 프로토콜(ICP)이나 하이퍼텍스트 캐시 프로토콜(HTCP) 같은 프로토콜을 이용해 HTTP를 확장한다

---

## 7.7 캐시 처리 단계

오늘날 상용 프락시 캐시는 꽤 복잡하다

고성능이면서 HTTP와 그 외 다른 기술의 고급 기능을 지원하도록 만들어졌다

몇 군데 미묘하지만 기본적인 동작은 대개 단순한다

HTTP GET 메서드 하나를 처리하는 기본적은 캐시 처리 절차는 일곱 단계로 이루어져 있다
1.  요청 받기 - 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다
2.  파싱 - 캐시는 메시지를 파싱하여 URL과 헤더들을 추출한다
3.  검색 - 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아오고 로컬에 저장한다
4.  신선도 검사 - 캐시는 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다
5.  응답 생성 - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다
6.  발송 - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다
7.  로깅 - 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다


### 7.7.1 단계 1: 요청 받기

캐시는 네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어들인다

고성능 캐시는 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 도착하기 전에 트랜잭션 처리를 시작한다


### 7.7.2 단계 2: 파싱

캐시는 요청 메시지를 여러 부분으로 파싱하여 헤더부분을 조작하기 쉬운 자료 구조에 담는다

캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만들어준다


### 7.7.3 단계 3: 검색

캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사한다

전문적인 수준의 캐시는 객체를 로컬 캐시에서 가져올 수 있는지 판단하기 위해 빠른 알고리즘을 사용한다

만약 로컬에서 문서를 가져올 수 없다면, 캐시는 상황이나 설정에 따라서 원 서버나 부모 프락시에서 가져오거나 실패를 반환한다

캐시된 객체는 서버 응답 본문과 원 서버 응답 헤더를 포함하고 있으므로, 캐시 적중 동안 올바른 서버 헤더가 반환될 수 있다

캐시된 객체는 얼마나 오랫동안 캐시에 머무르고 있었는지를 알려주는 기록이나 자주 사용되었는지에 대한 정보 등 몇몇 메타 데이터를 포함한다


### 7.7.4 단계 4: 신선도 검사

HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해준다

해당 기간 동안은 새로운 문서로 간주되고 서버와의 접촉 없이 문서를 제공할 수 있다

하지만 너무 오래 되어 있었다면 캐시는 문서를 제공하기 전에 문서의 변경 여부를 원서버를 통해 검사해야 한다

HTTP의 신선도 검사 규칙을 매우 복잡한데, 많은 수의 설정 옵션과 비 HTTP 신선도 표준과의 상호작용 때문에 더 복잡해진다


### 7.7.5 단계 5: 응답 생성

캐시된 응답을 원 서버에게 온 것처럼 보이게 하고 싶기 때문에, 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성한다

캐시는 클라이언트에 맞게 이 헤더를 조정해야 하는 책임이 있다

예를들어, 클라이언트가 HTTP/1.1 응답을 기다리는데 서버가 HTTP 1.0 응답을 반환했다면, 헤더를 적절하게 번역해야한다

또한 캐시 정보를 삽입하며, 프락시 캐시를 거쳐갔음을 알려주기 위해 종종 Via 헤더를 포함시킨다

캐시가 Date 헤더를 조정해서는 안된다


### 7.7.6 단계 6: 전송

응답 헤더가 준비되면, 캐시가 응답을 클라이언트에게 돌려준다

모든 프락시 서버들과 마찬가지로, 클라이언트와의 커넥션을 유지할 필요가 있다

고성능 캐시는 종종 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력한다


### 7.7.7 단계 7: 로깅

대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지한다

캐시 트랜잭션 완료 이후, 캐시 적중과 부적중 횟수를 갱신하고 로그 파일에 요청 종류, URL 그리고 무엇이 일어났는지를 알려주는 항목을 추가한다

가장 많이 쓰이는 로그 포맷은 스퀴드 로그 포맷과 넷스케이프 확장 공용 로그 포맷이지만, 많은 캐시 제품이 커스텀 로그 파일을 허용한다


### 7.7.8 캐시 플로 차트

---

## 7.8 사본을 신선하게 유지하기


### 7.8.1 문서 만료

HTTP는 Cache-Control과 Expires라는 특별한 헤더들을 이용해서 원서버가 각 문서에 유효기간을 붙일 수 있게 해준다

캐시 문서가 만료되기 전에, 캐시는 필요하다면 서버와의 접촉 없이 사본을 제공할 수 있다

그러나 캐시된 문서가 만료되면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해야 하며, 새로운 사본을 가져와야 한다


### 7.8.2 유효기간과 나이

서버는 HTTP/1.0+ Expires나 HTTP/1.1 Cache-Control:max-age 응답 헤더를 통해 유효기간을 명시한다

기본적으로 같은 일을 하지만, 절대 시간은 컴퓨터의 시계가 올바르게 맞추어져 있을 것을 요구한다


### 7.8.3 서버 재검사

캐시된 문서가 만료되었다는 것은 검사할 시간이 되었다는 것이다
- 재검사 결과 콘텐츠가 변경되었다면, 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내준다
- 변경되지 않았다면, 새 만료일을 포함한 새 헤더들만 가져와 캐시 안의 헤더들을 갱신한다


### 7.8.4 조건부 메서드와의 재검사

HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다

HTTP는 캐시가 서버에게 ‘조건부 GET’이라는 요청을 보낼 수 있도록 해주며, 이 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것이다

일반 GET 요청에 특별한 헤더를 추가하면 되며 조건이 참인 경우에만 객체를 반환한다

HTTP는 다섯 가지 조건부 헤더를 정의하는데, 그 중 둘은 가장 유용한 If-Modified-Since, If-None-Match이다


### 7.8.5 If-Modified-Since: 날짜 재검사

흔히 쓰이는 캐시 재검사 헤더로, 흔히 ‘IMS’ 요청으로 불리며 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다

If-Modified-Since 헤더는 서버 응답 헤더의 Last-Modified 헤더와 함께 동작하며 원 서버는 제공하는 문서에 최근 변경 일시를 붙인다

재검사하려고 할때 캐시된 사본이 마지막으로 수정된 날짜가 담긴 If-Modified-Since 헤더를 포함한다

만약 콘텐츠가 그동안 변경되었다면, 최근 변경 일시는 다를 것이고 원 서버는 새 문서를 돌려줄 것이다

그렇지 않다면, 서버는 캐시의 최근 변경 일시가 서버에 있는 문서의 현재 최근 변경 일시와 같음을 발견하고 304 응답을 돌려줄 것이다

몇몇 웹 서버는 If-Modified-Since를 시렞 날짜 비교로 구현하지 않는 대신 IMS 날짜와 최근 변경일 간의 문자열 비교를 수행한다


### 7.8.6 If-None-Match: 엔터티 태그 재검사

최근 변경 일시 재검사가 적절히 행해지기 어려운 상황이 몇 가지 있다
- 어떤 문서는 일정 시간 간격으로 다시 쓰여지지만 실제로는 같은 데이터를 포함하고 있다 내용에는 아무런 변화가 없더라도 변경시각은 바뀔 수 있다
- 어떤 문사들의 변경은 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 것일 수 있다
- 어떤 서버들은 그들이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없다
- 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는, 1초의 정밀도로 충분하지 않다

이럴 때를 대비해 엔터티 태그를 새로운 버전으로 표현할 수 있으며, 이 때 If-None-Match 조건부 헤더를 사요할 수 있다


### 7.8.7 약한 검사기와 강한 검사기

캐시는 캐시된 버전이 서버가 갖고 있는 것에 대해 최신인지 확인하기 위해 엔터티 태그를 사용한다

서버는 때때로 캐시 사본을 무효화하지 않고 문서를 고치고 싶을 수 있다

HTTP/1.1 은 조금 변경된 것이 “그 정도면 같다"라고 주장할 수 있도록 해주는 ‘약한 검사기'를 지원하며, 강한 검사기는 콘텐츠가 바뀔 때마다 바뀐다

조건부 특정 범위 가져오기 같은 몇몇 동작은 약한 검사기로는 불가능하기 때문에, ‘W/’ 접두사로 약한 검사기를 구분한다
- Etag: W/”v2.6”
- If-None-Match: W/”v2.6”

강한 엔터티 태그는 대응하는 엔터티 값이 어떻게 바뀌든 매번 같이 바뀌어야 한다

약한 엔터티 태그는 대응하는 엔터티에 유의미한 변경이 있을 때마다 같이 변경되어야 한다


### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

HTTP/1.1 클라이언트는 만약 서버가 엔터티 태그를 반환했다면, 반드시 엔터티 태그 검사기를 사용해야 한다

만약 서버가 Last-Modified 값만 반환했다면, 클라이언트는 If-Modified-Since 검사를 사용할 수 있다

만약 엔터티 태그와 최근 변경 일시 모두 사용 가능하면, HTTP/1.0, HTTP/1.1 모두 적절히 응답할 수 있도록 클라이언트는 두 가지 재검사 정책을 모두 사용해야 한다

HTTP/1.1 원 서버는 엔터티 태그 검사기를 보내야 하며, 약한 엔터티 태그를 보낼 수도 있으며, Last-Modified 값을 같이 보내는 것도 선호된다

---

## 7.9 캐시 제어

HTTP는 문서가 만료되기 전까지 얼마나 캐시될 수 있게 할지 서버가 설중할 수 있는 여러 방법이 정의되며 우선순위대로 나열한 것이다
- Cache-Control: no-store
- Cache-Control: no-cache
- Cache-Control: must-revalidate
- Cache-Control: max-age
- Expires 날짜 헤더
- 아무 만료 정보를 주지 않고, 캐시가 스스로 휴리스틱 방법으로 결정하게 할 수 있다


### 7.9.1 no-cache와 no-store 헤더

HTTP/1.1은 신선도를 관리하기 위해, 캐시하는 것을 제한하거나 캐시된 객체를 제공하는 여러 방법을 제공한다

no-store, no-cache 헤더는 검증되지 않은 캐시된 객체로 응답하는 것을 막는다

no-store가 표시된 응답은 캐시가 사본을 만드는 것을 금지한다

no-cache가 표시된 응답은 로컬 캐시 저장소로 저장될 수 있지만 먼저 사버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공할 수 없다

Pragma: no-cache 헤더는 HTTP/1.0+와의 하위호환성을 위해 HTTP/1.1에 포함되어 있다


### 7.9.2 Max-Age 응답 헤더

Cache-Control: max-age 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고, 초로 나타낸다

s-maxage 헤더는 max-age 처럼 행동하지만 공용 캐시에만 적용된다


### 7.9.3 Expires 응답 헤더

더 이상 사용하지 않기를 권하는 Expires 헤더는 초 단위 시간 대신 실제 만료 날짜를 명시한다

HTTP를 설계한 사람들은, 많은 서버가 부정확한 시계를 갖고 있기 때문에, 절대시각 대신 경과된 시간으로 표현하는 것이 낫다고 판단했다

신선도 수명의 근사값은 만료일과 생성일의 초 단위 시간차를 계산하여 얻을 수 있다

몇몇 서버들은 만료되도록 하기 위해 Expires:0 응답 헤더를 돌려보내지만, 문법 위반이며 문제를 일으킬 수 있다


### 7.9.4 Must-Revalidate 응답 헤더

캐시는 성능을 개선하기 위해 만료된 객체를 제공하도록 설정될 수 있다

만료 정보를 엄격하게 따르길 원할 경우, Cache-Control: must-revalidate 를 붙이면 된다

캐시가 이 객체의 만료된 사본을 원 서버와의 재검사 없이 제공해서는 안된다는 것을 말한다

캐시는 자유롭게 신선한 사본을 제공할 수 있지만, must-revalidate 신선도 검사를 시도했을 때 원서버가 사용할 수 없는 상태라면, 504를 반환한다


### 7.9.5 휴리스틱 만료

응답이 Cache-Control: max-age 헤더나 Expires 헤더 중 어느것도 포함하지 않았다면, 캐시는 휴리스틱으로 최대 나이를 계산할 것이다

어떤 알고리즘이든 사용될 수 있지만, 최대 나이 값이 24시간보다 크다면 Heuristic Expiration 경고 헤더가 응답 헤더에 추가되어야 한다 (하지만 브라우저에 보이진 않는다)

유명한 LM인자 알고리즘은, 문서가 최근 변경 일시를 포함하고 있어야 사용할 수 있으며, 최근 변경 일시를 문서가 얼마나 자주 바뀌는지에 대한 추정에 사용한다

일반적으로 휴리스틱 신선도 유지기간에 상한을 설정하여 지나치게 커지는 것을 막는다

보통 1주일, 보수적인 사이트는 하루로 설정한다

만약 최근 변경일 조차 없다면, 판단 근거가 없기 때문에 기본 신선도 유지기간을 설정한다 (한 시간에서 하루)

휴리스틱 신선도 계산은 흔히 하게 되는 일로, 많은 원 서버들이 아직도 Expires와 max-ag 헤더를 생성하지 못한다


### 7.9.6 클라이언트 신선도 제약

웹브라우저는 신선하지 않은 콘첸츠를 강제로 갱신시켜주는 리프레시나 리로드 버전을 갖고 있다

Cache-control 요청 헤더가 추가된 GET 요청을 발생시켜서, 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다

클라이언트는 Cache-Control 요청 헤더를 사용하여 만료 제약을 엄격하게 하거나 느슨하게 할 수 있다


### 7.9.7 주의할 점

만료는 완벽한 시스템이 아니다

퍼블리셔가 잘못해서 유효기간을 까마득한 미래로 설정해버린다면, 만료되기 전까지만 그 문서에 대한 어떤 변경도 캐시에 반영되지 않는다

많은 퍼블리셔가 유효기간을 길게 잡지 않으며, 아예 유효기간을 사용하지 않아서 얼마나 오랫동안 신선할 것인지 캐시가 알기 어렵게 되는 경우도 많다

---

## 7.10 캐시 제어 설정

웹 서버들은 캐시 제어와 만료 HTTP 헤더들을 설정하는 서로 다른 메커니즘을 제공한다


### 7.10.1 아파치로 HTTP 헤더 제어하기

**mod_headers**
- mod_headers 모듈은 개별 헤더들을 설정할 수 있게 해준다
- 한번 이 모듈이 로드되면, 개별 HTTP 헤더를 설정할 수 있는 지시어를 이용해 아파치 설정 파일에 설정을 추가할 수 있다
- 또한 개별 콘텐츠에 헤더들을 연결시키기 위해 정규식과 필터를 조합하여 사용할 수 있다

**mod_expires**
- 적절한 만료 날짜가 담긴 Expires 헤더를 자동으로 생성하는 프로그램 로직을 제공한다
- 마지막으로 접근한 날 혹은 수정한 날 이후의 일정 시한으로 유효기간을 설정할 수 있게 해준다

**mod_cern_meta**
- HTTP 헤더들의 파일을 특정 객체와 연결시켜준다
- 모듈을 켜면 제어하고자 하는 파일에 각각 대응되는 메타파일들을 생성하게 되므로, 각 메타파일에 원하는 헤더를 추가하면 된다


### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어

HTTP 서버 응답 헤더는 문서의 만료와 캐시 제어 정보를 돌려주기 위해 사용된다

웹 서버는 제공할 문서에 올바른 캐시 제어 헤더들을 부여하기 위해 설정 파일들과 상호작용한다

HTML 2.0은 `<META HTTP-EQUIV>` 태그를 정의하였고, 문서의 최상단에 위치하여 문서와 연동되어야 하는 HTTP 헤더들을 정의한다

HTTP-EQUIV 태그는 원래 웹 서버에서 사용되도록 의도된 것이이다

웹 서버는 HTML 에서 태그를 파싱하여 HTTP 응답에 정해진 헤더를 삽입할 것이다

하지만 해당 기능을 지원하는 웹 서버나 프락시는 거의 없다

왜냐하면 서버의 부하를 가중시키고, 설정값이 정적이고, HTML을 제외한 다른 타입의 파일은 지원하지 않기 때문이다

`<META HTTP-EQUIV>` 태그는 문서의 캐시 동작을 제어할때 좋지 못한 방법이다

유일하게 확실한 방법은 올바르게 설정된 서버가 보내온 HTTP 헤더를 이용하는 것이다

---

## 7.11 자세한 알고리즘

생략

---

## 7.12 캐시와 광고


### 7.12.1 광고 회사의 딜레마

콘텐츠 제공가즐은 수요를 견디기 위해 대용량 멀티 프로세서 웹 서버를 살 필요가 없으며, 같은 데이터를 계속 반복해서 보여주면서 드는 비용도 줄일 수 있다

또한 사용자의 스크린에 빠르면서 더 잘보여줌으로써, 더 많은 콘텐츠를 소비하고 더 많은 광고를 보게 할 수 있다

콘첸트 제공자가 광고를 통해 돈을 벌지만, 캐시와 관련된다면 문제가 된다

캐시는 원서버가 실제 접근 횟수를 알 수 없게 숨길 수 있다. 캐싱이 완벽하게 동작할 경우 원 서버는 요청을 전혀 수신하지 않는다

따라서 광고 접근 횟수로 돈을 벌 경우에는 달갑지 않다


### 7.12.2 퍼블리셔의 응답

오늘날 캐시가 광고 시청수를 가로채지 못하도록 ‘캐시 무력화' 기법을 사용한다

그들은 광고를 CGI 게이트웨이를 통해 제공하며, 매 접근마다 광고 URL을 고쳐 쓴다

그리고 캐시 무력화 기법은 단시 프락시 캐시만에 대한 것이 아니라, 모든 웹브라우저에서 켜져 있는 캐시를 주요 대상으로 하고 있다

하지만 이러한 과한 시도는 그들의 사이트에 대한 캐싱의 긍정적인 효과를 감소시킨다

이상적으로는 콘텐츠 제공자는 캐시가 그들의 트래픽을 흡수하도록 내버려두어야 하며, 캐시는 적중이 얼마나 많이 일어났는지 알려주어야 한다

한 가지 방법은 모든 접근에 대해 원 서버와 재검사하도록 캐시를 설정하는 것으로, 원 서버에 캐시 적중이 있었음을 알리지만 본문 데이터를 전송하지는 않는다


### 7.12.3 로그 마이그레이션

이상적인 해결책 하나는 서버로 요청이 가지 않도록 하는 것이며, 결국 캐시는 모든 적중의 로그를 유지할 수 있다

캐시는 해당 로그를 서버에 나누어 줄 수 있으며, 몇몇 캐시 제공자들은 캐시 로그를 수동으로 처리해서 직접 건네주기도 한다

적중 로그는 크기가 크고, 캐시 로그는 개별 콘텐츠 제공자별로 분리될 수 있도록 표준화, 조직화되어 있지 않는다

또한 인증과 프라이버시 이슈도 존재한다


### 7.12.4 적중 측정과 사용량 제한

RFC 2227는 더 간단한 방법을 정의한다

해당 프로토콜은 HTTP에 때때로 특정 URL에 대한 캐시 적중 횟수를 정기적으로 서버에게 돌려주는 Meter라고 하는 새 헤더를 추가한다

캐시된 문서가 적중한 횟수의 정기적인 업데이트를 캐시로부터 서버가 받는다

추가적으로, 서버는 캐시가 서버에게 보고하기 전까지 문서 제공 가능 횟수나 소모 가능한 시간을 제어할 수 있으며, 이를 사용량 제한이라고 한다

해당 방식은 캐시가 원 서버에게 보고하기 전에 캐시된 리소스가 얼마나 사용될 수 있는지 서버가 제어할 수 있게 해준다