현대에는 배포 도구를 이용하면 웹 콘텐츠의 생성, 배포, 관리를 더 쉽게 할 수 있다

웹 콘텐츠를 화면에서 직접 보면서 작성할 수 있고, 단 한 번의 클릭으로 모든 파일이 하나씩 배포되고 있다는 알림을 받으면서 서버에 콘텐츠를 배포할 수 있다

## 19.1 배포 지원을 위한 FrontPage 서버 확장

FrontPage는 다양한 기능을 제공하는 MS사의 웹 개발 및 배포 도구 집합이다

### 19.1.1 FrontPage 서버 확장

"어디서든 배포한다"라는 전략의 하나로, FrontPage 서버 확장이라는 소프트웨어 제품군을 출시했다

-   서버 측 컴포넌트는 웹 사이트와 FrontPage를 구동시키는 클라이언트 사이에서 필요한 변환 작업을 수행한다
-   FrontPage 배포 프로토콜은 POST 요청 위에 RPC 계층을 구현했다

### 19.1.2 FrontPage 용어

**_가상 서버_**

-   같은 서버에 올라가 있는 여러 웹 사이트는 각각 유일한 도메인 이름과 IP 주소를 가진다
-   가상 서버를 지원하는 웹 서버를 다중 호스팅 웹 서버라 부른다
-   여러 개의 IP 주소로 구성된 장비는 다중 홈 서버라 부른다

**_루트 웹_**

-   보통 웹 서버의 최상위 콘텐츠 디렉터리, 다중 호스팅 환경에서는 가상 웹 서버의 최상위 콘텐츠 디렉터리이다
-   서버의 URL만 기술하면 접속 가능한 웹이다

**_서브 웹_**

-   루트 웹의 하위디렉터리 이거나 완전한 FPSE 확장 웹인 다른 서버 웹의 하위 디렉터리이다
-   서브 웹은 관리나 저작의 권한을 자체적으로 제한하는 독립적인 엔터티가 될 수 있다
-   검색 범위의 단위로 사용할 수도 있다

### 19.1.3 FrontPage RPC 프로토콜

FrontPage 클라이언트와 FPSE(FrontPage Server Extension)는 자체 RPC 프로토콜을 사용해 통신한다

-   해당 프로토콜은 RPC 메서드와 관련 변수를 POST 요청의 본문에 기술한다

통신을 시작하려면, 클라이언트는 서버에 있는 대상 프로그램의 이름과 위치를 결정해야 한다

-   이를 위해 특별한 GET 요청을 보낸다

파일이 반환되면, 클라이언트는 응답을 읽고, FP 관련 값을 찾는다

-   FPShtmlScriptUrl: browse time 명령에 관한 POST 요청을 보낼 위치를 클라이언트에게 알려준다
-   FPAuthorScriptUrl: authoring time 명령에 관한 POST 요청을 보낼 위치를 클라이언트에게 알려준다
-   FPAdminScriptUrl: 관리 동작에 관한 POST 요청이 실행되어야 할 위치를 알려준다

**_요청_**

-   POST 요청의 본문에는 "method= \<command>" 형식의 RPC 명령에 함께 필요한 모든 매개변수가 기술되어 있다
-   POST 명령의 본문에는 FPSE에 보내는 RPC 명령이 기술되어 있다
-   메서드 내의 빈칸은 '+'로 인코딩되며, 알파벳 외 문자는 아스키로 인코딩된다
-   명령의 요소들은 다음과 같다
    -   service_name: 메서드가 수행되어야 하는 웹 사이트의 URL
    -   listHiddenDocs: 값이 true면 웹에 숨겨진 문서가 보이며, "hidden" 문서는 "\_"로 시작하는 경로 컴포넌트가 기술된 URL이다
    -   listExploreDocs: 값이 true면 태스크 리스트를 나열한다

**_응답_**

-   RPC 프로토콜 메서드 대부분은 반환 값이 있으며, 가장 일반적인 값은 성공 메서드와 에러이다
-   특정 메서드는 "Sample Return Code"를 포함하기도 한다
-   웹 서버에서 유효한 문서의 목록을 특정 형식에 맞추어 작성해 FP 클라이언트에 반환한다

### 19.1.4 FrontPage 보안 모델

직접 웹 서버 콘텐츠에 접근하는 모든 배포 시스템은 배포하는 과정에서 보안에 신경 써야 한다

FPSE 보안 모델은 사용자를 세 가지로 정의한다

-   관리자, 저작자, 일반 사용자
-   해당 사용자들의 목록은 특정 FPSE 확장 웹에 따라 다르게 정의된다
    -   서브웹은 루트웹에서 권한을 상속받거나 자체 권한이 있다
    -   IIS 서버에서는, 통합된 윈도우 보안 모델이 우선 적용된다

IIS가 아닌 서버의 웹 서버 접근 제어 메커니즘에서는, 허가된 사용자들을 따로 기술한다

IIS 서버에는, 권한이 있는지에 대한 검사는 루트나 서브 루트에 대한 ACL을 보고 검사한다

## 19.2 WebDAV와 공동 저작

웹 분산 저작과 비저닝(Web Distributed Authoring and Versioning, WebDAV)은 또 다른 웹 배포 공동 작업이다

WebDAV는 공동 저작에 적합한 플랫폼을 제공하려고 HTTP를 확장하는 데 집중하였다

### 19.2.1 WebDAV메서드

**_PROPFIND_**

-   리소스의 속성을 읽는다

**_PROPPATCH_**

-   한 개 이상의 리소스에 대해 한 개 이상의 속성을 설정한다

**_MKCOL_**

-   콜렉션을 생성한다

**_COPY_**

-   특정 원본지에서 특정 목적지로 한 개 이상의 리소스를 복사한다

**_MOVE_**

-   특정 원본지에서 특정 목적지로 한 개 이상의 리소스를 이동시킨다

**_LOCK_**

-   하나 이상의 리소스를 잠근다

**_UNLOCK_**

-   기존에 잠겨있는 리소스를 잠금 해제한다

### 19.2.2 WebDAV와 XML

WebDAV의 메서드는 요청와 응답에 관련 정보를 HTTP의 헤더에 담아 전달한다

-   하지만 헤더에만 정보를 담아 전송할 경우, 하나의 요청에 여러 리소스나 계층 관계에 있는 리소스 정보를 모두 담기에는 기술적으로 어렵다
-   따라서 XML을 지원한다

WebDAV는 XML을 다음과 같은 용도로 사용한다

-   데이터를 어떻게 처리할 것인지 설명하는 명령 포맷
-   서버의 복잡한 응답을 표현하는 데 사용하는 포맷
-   콜렉션과 리소스를 처리하는 데 사용하는 커스텀 정보 포맷
-   데이터 자체를 표현할 수 있는 유연한 포맷
-   대부분의 국제화 관련 문제에 대한 훌륭한 해결책

전통적으로 XML 문서의 스키마 정의는 문서 내부에서 자체적으로 참조하는 문서 타입 정의(DTD)를 준수한다

-   따라서 문서를 해석하려고 할때, 해당 XML문서와 관련된 DTD 파일의 이름을 제공한다

WebDAV는 "DAV:"라는 별도의 XML 이름공간을 정읳나다

-   XML 이름공간은 요소나 속성 이름의 집합이다
-   이름 공간은 도메인 전체에서 유일한 이름을 보장한다
-   복잡한 XML 스키마는 WebDAV 명세인 RFC 2518에 정의되어 있다

### 19.2.3 WebDAV 헤더

새로운 메서드들의 기능을 넓혀주기 위해 도입한 HTTP 헤더들은 다음과 같다

**_DAV_**

-   WebDAV를 제공하는 서버와 통신할 때 사용한다
-   WebDAV에서 지원하는 모든 리소스는 OPTIONS 요청에 대한 응답에 이 헤더를 포함해야 한다

**_Depth_**

-   여러 수준의 계층 구조로 분류된 리소스에 WebDAV를 사용하기 위한 중요한 요소이다
-   Depth 헤더는 WebDAV가 정의하고 있는 여러 메서드를 수정한다 (LOCK, COPY, MOVE)

**_Destination_**

-   COPY, MOVE 메서드가 목적이 URI를 식별하는데 쓰인다

**_If_**

-   정의되어 있는 상태 토큰은 lock 토큰 뿐이다
-   If 헤더는 조건 정의를 정의하는데, 조건들에 모두 맞지 않으면, 요청은 실패한다
-   COPY나 PUT 같은 메서드는 If 헤더에 전제 조건을 기술해서 적용하는데 필요한 조건을 단다

**_Lock-Token_**

-   제거되어야 할 lock을 명시하는 용도로 UNLOCK 메서드에서 사용한다

**_Overwrite_**

-   대상을 덮어쓸 것인지 아닌제를 기술하는 데 쓰이며, COPY, MOVE 메서드에서 사용한다

**_Timeout_**

-   클라이언트가 필요한 잠금 타임아웃 값을 기술하는 데 사용하는 요청 헤더이다

### 19.2.4 WebDAV 잠금과 덮어쓰기 방지

여러 명이 작업할 때, 배포에 대한 업데이트를 하지 않은 상태에서 배포하게 된다면 문제가 생긴다

-   이를 위해 잠금이라는 개념을 지원한다

배타적 쓰기 잠금

-   잠금 소유자만 쓸 수 있게 보장한다
-   잠재적인 충돌을 완벽히 제거한다

공유된 쓰기 잠금

-   여러 사람으로 이루어져 있는 그룹이 하나의 문서에서 작업할 수 있게 한다
-   모든 저자가 각각 서로의 활동을 인식하고 있는 상황에서 잘 동작한다

WebDAV는 지원할 잠금과 형식을 결정하기 위해 PROPFIND를 사용한다

잠금이 승인되면, 서버는 도메인 전체에서 유일한 토큰을 클라이언트에 반환한다

-   이후 서버에 쓰기를 보낼 때, 서버에 연결하고 다이제스트 인증을 수행한다
-   인증이 완료되면, WebDAV 클라이언트는 PUT 요청을 통해 잠금 토큰을 보낸다

### 19.2.5 LOCK 메서드

WebDAV의 강력한 기능은 한 개의 LOCK 요청으로 여러 개의 리소스를 잠글 수 있다는 것이다

-   LOCK 요청이 있을 때에, 전송된 XML에는 기본 요소로 lockinfo를 가진다
-   해당 lockinfo 구조 안에 세 개의 하위 요소가 있다
    -   \<locktoken>: 잠금 형식을 가리킨다
    -   \<lockscope>: 배타적 잠금인지 공유된 잠금인지를 가리킨다
    -   \<owner>: 현재 잠금을 가지고 있는 사람이 기술되어 있는 필드다

LOCK 요청에 대해 성공한 응답의 lockdiscovery는 잠금에 대한 정보를 담는다

-   해당 요소 안에 있는 activelock은 아래의 하위 요소를 갖는다
    -   \<locktoken>: opaquelocktoken이라고 뿌르는 토큰으로 잠금을 식별하는데 사용한다
    -   \<depth>: Depth 헤더와 같은 값을 가진다
    -   \<timeout>: 잠금에 대한 타임아웃을 가리킨다

**_opaquelocktoken_**

-   모든 리소스에 유일한 토큰을 제공하기 위해 설계되었다
-   유일성을 위해 UUID 메커니즘을 사용한다

**_\<lockdiscovery> XML 요소_**

-   활성화되어 있는 잠금을 찾는 메커니즘을 제공한다
-   이미 잠겨져 있는 파일을 누군가 잠그려 한다면, 현재 주인을 가리킨다

**_잠금 갱신과 Timeout 헤더_**

-   잠금을 갱신하려면 클라이언트는 If 헤더에 잠금 토큰과 함께 잠금 요청을 다시 보내야 한다
    -   반환된 timeout 값은 이전의 timeout값과 다를 것이다
-   클라이언트는 LOCK 요청에 필요한 timeout 값을 기술하며, Timeout 헤더에 기술한다

### 19.2.6 UNLOCK 메서드

UNLOCK 메서드는 리소스에 있는 잠금을 제거한다

UNLOCK이 성공하기 위한 두 가지 조건이 있다

-   다이제스트 인증을 성공적으로 완료하는 것
-   Lock-Token 헤더에 보내는 잠금 토큰이 맞는지 검사하는 것

그에 대한 상태 코드들은 다음과 같다

-   200: 잠금 성공
-   201: 리소스를 생성하여 존재하지 않는 리소스에 대한 잠금 성공
-   204: 잠금 해제 성공
-   207: 여러 리소스를 잠그기 위한 요청 반환
-   403: 권한 없음
-   412: XML에 기술된 조건이 서버에 맞지 않거나 잠금 토큰 수행 불가
-   422: 처리할 수 없음
-   423: 이미 잠금 상태
-   424: 잠금 해제를 하기 위한 조건이 부합하지 않을 경우

### 19.2.7 속성과 META 데이터

속성에는 저작자의 이름, 수정 날짜, 내용 등급 등과 같은 리소스의 정보를 기술한다

WebDAV과 같은 분산 협업 시스템은 더 복잡한 속성을 가진다

-   동적 수정 속성은 'live' 속성이라고 한다
-   거의 변하지 않는 정적 속성 'dead' 속성이라고 한다

속성의 발견과 수정을 위해 PROPFIND, PROPPATCH 라는 확장된 메서드를 사용한다

### 19.2.8 PROPFIND 메서드

PROPFIND(property find) 메서드는 주어진 파일이나 파일 그룹의 속성을 읽는데 사용하며 세가지 동작을 지원한다

-   모든 속성과 그 값을 요청한다
-   선택된 속성과 그 값의 집합을 요청한다
-   모든 속성의 이름을 요청한다

요청할 때에 \<propfind> 요소는 PROPFIND 메서드로부터 반환될 속성들을 기술하며 아래를 포함한다

-   \<allprop>: 반환될 모든 속성의 이름과 값을 기술한다
-   \<propname>: 반환될 속성 이름의 집합을 기술한다
-   \<prop>: \<propfind> 요소의 하위 요소로, 반환될 값을 기술한다

응답은 아래의 요소들을 포함한다

-   \<multistatus>: 여러 응답을 담는 컨테이너
-   \<href>: 리소스의 URI를 가리킨다
-   \<status>: 특정 요청에 대한 HTTP 상태 코드를 기술한다
-   \<propstat>: \<status> 한 개와 \<prop> 한개로 일루어져 있는 집합이다

PROPFIND를 활용하는 한 가지 예는 디렉터리 목록을 얻는 것이다

-   호출 한번으로 목록의 계층 관계 전체와 안에 있는 개별 엔터티의 모든 속성까지 읽을 수 있다

### 19.2.9 PROPPATCH 메서드

PROPPATCH 메서드는 특정 리소스의 여러 속성을 설정하거나 제거하는 원자적 메커니즘을 제공한다

-   원자성은 모든 요청이 성공하거나 무효 하나만 수행되는 것을 보장한다

기본 XML 요소는 \<propertyupdate>으로, 업데이트가 필요한 모든 속성을 담는 컨테이너이다

-   \<set>: 설정할 속성을 기술하며, 이름/값 쌍의 속성을 기술한 한 개 이상의 \<prop> 하위 요소를 포함한다
-   \<remove>: 제거할 속성을 기술하며, 이름을 기술한 \<prop> 하위 요소를 포함한다

PROPFIND 메서드와 PROPPATCH 메서드에 대한 응답 코드이다

-   200: 명령 성공
-   207: 한 개 이상의 리소스에 대한 여러 응답
-   401: 속성 수정을 위한 인증 요청
-   403: PROPFIND는 접근 권한이 없음, PROPPATCH는 속성을 변경할 수 없음
-   404: 해당 속성 없음
-   409: 업데이트 충돌
-   423: 접근하려는 목적지의 리소스가 잠겨있으며, 잠금 토큰이 없거나 불일치
-   507: 수정된 속성을 저장할 공간 부족

### 19.2.10 콜렉션과 이름공간 관리

콜렉션은 계층에 있는 리소스들의 논리적 혹은 물리적 그룹이다

-   대표적인 예로 디렉터리가 있다
-   콜렉션은 다른 콜렉션을 포함한다

WebDAV는 XML 이름공간 메커니즘을 사용한다

WebDAV는 이름공간을 관리하는 다섯 가지 메서드를 제공한다

-   DELETE, MKCOL, COPY, MOVE, PROPFIND

### 19.2.11 MKCOL 메서드

MKCOL 메서드는 클라이언트가 지정된 URL에 해당하는 콜렉션을 서버에 생성하게 한다

-   PUT이나 POST를 사용하지 않은 이유는 다음과 같다
    -   콜렉션을 생성할 목적으로 PUT이나 POST를 사용하려면, 요청 안에 추가 정보를 더해야한다
    -   대부분의 접근 제어 메커니즘은 메서드의 타입에 기반해 동작하기 때문에 용도와 같게 만들어야 한다

파일이나 콜렉션이 생성되면, DELETE 메서드로 삭제할 수 있다

### 19.2.12 DELETE 메서드

디렉터리를 디우기 위해서는 Depth 헤더가 필요하다

-   Depth 헤더가 기술되어 있지 않으면, 무한으로 설정되어 있다고 가정한다
-   그럴 경우 모든 디렉터리가 지워지게 된다

콜렉션을 제거하려 할 때, 누군가에 의해 잠겨져 있는 상태로 지울 수 없을 수 있다

### 19.2.13 COPY와 MOVE 메서드

COPY와 MOVE 메서드는 요청 URL을 원본의 위치 정보로 사용하고 목적지인 Destination HTTP 헤서의 값을 목적지 정보로 사용한다

MOVE 메서드는 COPY 메서드에 이어 몇 가지 추가 작업을 수행한다

-   원본지 URL을 목적지에 복사한다
-   새로 생성된 URI의 무결성을 검사한다
-   원본을 지운다

COPY나 MOVE가 컬렉션을 처리할 때 Depth 헤더에 영향을 받는다

-   Depth 헤더가 없으면 무한대 깊이로 가정하고 수행된다
-   Depth가 0이면, 해당 리소스에만 적용된다

**_Overwrite 헤더의 영향_**

-   COPY나 MOVE 메서드도 Overwrite 헤더를 사용할 수 있다
-   T나 F를 설정할 수 있다

**_COPY/MOVE의 속성_**

-   콜렉션이나 요소를 복사하면, 기본적으로 모든 속성이 복사된다
-   하지만 요청은 작업에 대한 추가 정보를 기술한 XML 본문을 포함할 수 있다
-   여기에는 반드시 모든 속성이 성공적으로 복사되어야 하거나, 어떤 속성만 복사하려고 하는 지 기술할 수 있다

**_잠긴 리소스와 COPY/MOVE_**

-   리소스가 잠겨있으면 COPY, MOVE 둘다 금지된다
-   현재 잠겨 있는 콜렉션 아래의 목적지로 하는 COPY, MOVE가 수행되면, 복사 혹은 리소스도 잠기게 된다

### 19.2.14 향상된 HTTP/1.1 메서드

WebDAV는 HTTP 메서드인 DELETE, PUT, OPTIONS의 의미를 수정 했다

-   GET, HEAD 의미는 바꾸지 않고 그대로 두었다
-   POST 요청은 특정 서버 구현에 따라 다르고, WebDAV에서는 변하지 않았다

**_PUT 메서드_**

-   PUT 메서드는 저작자가 공용 사이트에 콘텐츠를 전송하는 유일한 방법이다

**_OPTIONS 메서드_**

-   WebDAV를 사용하는 클라이언트가 보내는 첫 요청에 쓰인다
-   OPTIONS 메서드를 통해 WebDAV가 어떤 것들을 제공하는 지 알아볼 수 있다
-   응답으로 오는 DAV 헤더는 DAV 지원 클래스에 대한 정보를 제공한다
    -   Class 1 지원: RFC 2518의 MUST 요구사항을 지원한다
    -   Class 2 지원: Class 1에 더불어 LOCK 메서드를 지원한다
-   또한 다른 헤더들도 존재한다
    -   Public: 서버에서 지원하는 모든 메서드가 기술되어 있다
    -   Allow: 해당 리소스에 허락된 메서드들만 기술되어 있다
    -   DASL: SEARCH 메서드에서 사용하는 질의 문법의 형식이 기술되어 있다

### 19.2.15 WebDAV의 버전 관리

여러 명이 저작을 하는 상황에서, 공동 작업 환경과 버전 관리는 중요하다

수정한 것이 유실되는 문제를 방지하려면, 잠금과 비저닝이 필수이다
