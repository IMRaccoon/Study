## 21.1 로그란 무엇인가?

대개 로깅을 하는 이유는 두 가지이다

-   서버나 프락시의 문제를 찾는다
-   웹 사이트 접근 통계를 내려고 로깅을 한다

보통 트랜잭션은 기본적인 항목들만 로깅한다

-   HTTP 메서드
-   클라이언트와 서버의 HTTP 버전
-   요청받은 리소스의 URL
-   응답의 HTTP 상태코드
-   요청과 응답 메시지의 크기 (모든 엔터티 본문을 포함)
-   트랜잭션이 일어난 시간
-   Referer와 User-Agent 헤더 값

## 21.2 로그 포맷

애플리케이션이 더 많은 표준 포맷을 지원하고 관리자가 그것을 사용함으로써 얻는 이점은 관리자가 직접 지정한 필드를 포함한 로그 포맷과 그를 통한 통계를 추출할 수 있다는 것이다

### 21.2.1 일반 로그 포맷(Common Log Format)

많은 서버가 일반 로그 포맷(Common Log Format)을 기본으로 사용한다

일반 로그 포맷의 필드는 아래와 같다

-   remotehost: 요청한 컴퓨터의 호스트명 혹은 IP 주소
-   username: ident 검색을 수행했다면, 인증된 요청자의 사용자 이름
-   auth-username: 인증을 수행했다면, 인증된 요청자의 이름
-   timestamp: 요청 날짜와 시간
-   request-line: HTTP 요청의 행을 그대로 기술
-   response-code: 응답으로 보내는 HTTP 상태코드
-   repsonse-size: 응답 엔터티의 Content-Length

### 21.2.2 혼합 로그 포맷(Combined Log Format)

혼합 로그 포맷은 일반 로그 포맷과 매우 유사하다

추가된 필드는 다음과 같다

-   Referer: Referer HTTP 헤더의 값
-   User-Agent: User-Agent Referer HTTP 헤더의 값

### 21.2.3 넷스케이프 확장 로그 포맷

넷스케이프의 포맷은 일반 로그 포맷에서 시작했지만, 프락시나 웹 캐시 같은 애플리케이션과 연관 있는 환경들을 지원하려고 포맷을 확장했다

-   proxy-response-code: 트랜잭션이 프락시를 거칠 경우, 서버에서 프락시로의 HTTP 응답 코드
-   proxy-response-size: 트랜잭션이 프락시를 거칠 경우, 서버가 프락시에 전달하는 응답 엔터티의 Content-Length
-   client-request-size: 클라이언트가 프락시로 보내는 요청의 본문이나 엔터티의 Content-Length
-   proxy-request-size: 트랜잭션이 프락시를 거칠 경우, 프락시가 서버로 보내는 요청의 본문이나 엔터티의 Content-Length
-   client-request-hdr-size: 클라이언트 요청 헤더의 바이트 길이
-   proxy-response-hdr-size: 트랜잭션이 프락시를 거칠 경우, 프락시가 요청자에게 보내는 응답 헤더의 바이트길이
-   proxy-request-hdr-size: 트랜잭션이 프락시를 거칠 경우, 프락시가 요청자에게 보내는 응답 헤더의 바이트 길이
-   server-response-hdr-size: 서버 응답 헤더의 바이트 길이
-   proxy-timestamp: 트랜잭션이 프락시를 거칠 경우, 요청과 응답이 프락시를 통해 오가는 총 시간

### 21.2.4 넷스케이프 확장 2 로그 포맷

확장 로그 포맷에서 HTTP 프락시와 웹 캐시 애플리케이션과 관련한 더 많은 정보를 포함한다

넷스케이프 확장 2 로그 포맷은 넷스케이프 확장 로그 포맷에서 파생되어, 추가 필드가 존재한다

-   route: 프락시가 클라이언트에 요청을 만드는데 사용하는 경로
    -   DIRECT: 리소스를 서버에서 바로 가져왔다
    -   PROXY(host:port): 리소스를 host라는 프락시를 통해 가져왔다
    -   SOCKS(socks:port): 리소스를 host라는 SOCKS 서버를 통해 가져왔다
-   client-finish-status-code: 클라이언트의 종료 상태 코드로, 클라이언트가 프락시로 보낸 요청의 결과를 기술한다
    -   -: 요청이 시작되지 않았다
    -   FIN: 요청이 성공적으로 완료되었다
    -   INTR: 요청이 클라이언트에 의해 중단됐거나 프락시/서버에 의해 종료되었다
    -   TIMEOUT: 요청이 프락시/서버의 타임아웃에 걸렸다
-   proxy-finish-status-code: 프락시의 종료 상태 코드로, 프락시가 서버로 보낸 요청의 결과를 기술한다
    -   -: 요청이 시작되지 않았다
    -   FIN: 요청이 성공적으로 완료되었다
    -   INTR: 요청이 클라이언트에 의해 중단됐거나 프락시/서버에 의해 종료되었다
    -   TIMEOUT: 요청이 프락시/서버의 타임아웃에 걸렸다
-   cache-result-code: 캐시 결과 코드로, 캐시가 요청에 어떻게 응답했는지 기술한다
    -   -: 캐시할 수 없는 리소스다
    -   WRITTEN: 리소스를 캐시에 저장했다
    -   REFRESHED: 리소스를 캐시했고 갱신했다
    -   NO-CHECK: 캐시된 리소스를 반환했고 신선도 검사를 하지 않았다
    -   UP-TO-DATE: 캐시된 리소스를 반환했고 신선도 검사를 완료했다
    -   HOST-NOT-AVAILABLE: 캐시된 리소스를 반환했으며 원격 서버가 사용할 수 있는 상태가 아니었기 때문에 신선도 검사를 하지 않았다
    -   CL-MISMATCH: 리소스를 캐시에 저장하지 않았다. Content-Length가 리소스의 크기와 맞지 않았기 때문에 쓰기를 중단했다
    -   ERROR: 어떤 에러 때문에 리소스를 캐시에 저장하지 못했다. 예를 들면 타임아웃이 나거나 클라이언트가 트랜잭션을 중단했을 때

넷스케이프 애플리케이션은 관리자가 수정할 수 있는 유연한 로그 포맷(Flexible Log Format)을 포함한 다양한 로그 포맷으로 가지고 있다

### 21.2.5 스퀴드(Squid) 프락시 로그 포맷

스쿼드 프락시 캐시는 웹 분야에서 권위 있는 프로젝트이다

많은 차세대 프락시 캐시들이 이러한 도구를 활용하려고 자체 로그 포맷으로 스퀴드 포맷을 적용했다

스퀴드 로그 엔트리의 포맷은 꽤 단순하다

-   timestamp: 요청이 도착한 시간을 GMT 기준으로 지난 시간을 초 단위로 기술
-   time-elapsed: 요청과 응답이 프락시를 통해 오고간 총 시간을 밀리초로 기술
-   host-ip: 클라이언트의 호스트 장비 IP 주소
-   result-code/status: result 필드에는 이 요청에 프락시가 어떤일을 했는지 스퀴드 방식으로 기술되며, code 필드는 프락시가 클라이언트에 보낸 HTTP 응답 코드
-   size: 프락시가 클라이언트에게 보낸 HTTP 응답 헤더와 본문을 포함한 응답의 길이가 바이트 길이로 기술
-   method: 클라이언트 요청의 HTTP 메서드
-   url: 클라이언트 요청의 URL
-   rfc931-ident: 클라이언트에 인증된 사용자 이름
-   hierarchy/from: 프락시가 클라이언트로 요청을 보내면서 거친 경로를 기술하고, from 필드는 프락시가 요청을 만들게 한 서버의 이름을 기술한다
-   content-type: 프락시 응답 엔터티의 Content-Type

## 21.3 적중 계량하기

클라이언트와 서버 사이에 캐시가 있어, 많은 요청들이 서버까지 도달하지 않는다

-   요청이 원 서버까지 오지 않아도 정상적으로 처리될 수 있다
-   따라서 콘텐츠가 접근했다는 기록을 서버에 남기지 않아 로그 파일에 누락이 발생한다

로그 데이터가 유실되기 때문에, 중요한 페이지의 캐시를 파기한다

-   캐시가 파기되면 콘텐츠 생성자가 의도적으로 콘텐츠에 캐시되지 않도록 하는것이다
-   따라서 모든 요청이 원 서버로 하며, 이를 통해 리소스에 대한 접근을 로깅할 수 있다
-   하지만 응답 속도는 느려지고 네트워크의 부하가 가중된다

프락시 캐시들은 자체 로그를 유지하기 때문에, 캐시 파기를 피할 수 있다

-   적중 계량(Hit Metering) 규약은 HTTP의 확장으로 로그를 유지할 수 있게 된다
-   캐시가 정기적으로 캐시 접근 통계를 원 서버에 보고하도록 한다

### 21.3.1 개요

적중 계량 규약은 캐시와 서버가 접근 정보를 공유하고, 사용할 수 있는 캐시 리소스의 양을 제어할 수 있는 몇 가지 기초적인 기능에 관한 HTTP 확장을 정의한다

하지만 널리 구현되어 있거나 사용되는 규약이 아니다

### 21.3.2 Meter 헤더

Meter 라는 새로운 헤더를 추가했는데, 사용량이나 보고에 관한 지시자에 기술할 수 있다

-   will-report-and-limit: 캐시는 사용량을 보고하고 서버가 기술한 모든 사용 제한에 복종한다
-   wont-report: 캐시는 사용 제한에 복종하지만, 사용량 보고는 하지 않았다
-   wont-limit: 캐시는 사용량 보고를 하지만 사용 제한은 없다
-   count: "사용 횟수/재사용 횟수" 순으로 정수로 기술하는 보고 지시자이다
-   max-uses: 서버가 캐시를 사용해서 응답할 수 있는 최대 횟수를 기술한다
-   max-reuses: 서버가 캐시를 재사용해서 응답할 수 있는 최대 횟수를 기술한다
-   do-report: 서버가 프락시에게 사용량 보고를 요구한다
-   dont-report: 서버가 사용량 보고를 원하지 않는다
-   timeout: 서버가 리소스를 계량할 때 시간 제한을 거는데 사용한다
-   wont-ask: 서버는 계량 정보를 원하지 않는다

## 21.4 개인 정보 보호에 대해

실제 로깅은 서버와 프락시에서 수행하는 관리 기능이다

-   따라서 모든 것이 사용자의 트랜잭션에 적용된다
-   사용자는 자신의 HTTP 트랜잭션이 로깅되고 있다는 것을 모를 수 있다
