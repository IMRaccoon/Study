## 13.1 다이제스트 인증의 개선점

기본 인증의 결함을 수정한 또 다른 HTTP 인증 프로토콜이다
- 비밀번호를 절대 네트워크를 통해 평문으로 전송하지 않는다
- 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다
- 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다
- 그 외 몇몇 잘 알려진 형태의 공격을 막는다

다이제스트 인증이 가능한 가장 안전한 프로토콜은 아니며, 안전한 HTTP 트랜잭션을 위한 많은 요구사항을 만족하지 않는다

그러한 요구사항들에는 전송 계층 보안과 보안 HTTP가 더 적합한 프로토콜이다

하지만 기본 인증을 대체하기 위한 용도로는 강력한 기능들이 존재한다

강력하지만 아직 널리 쓰이지는 않았으며, 어떻게 될지는 모른다


### 13.1.1 비밀번호를 안전하게 지키기 위해 요약 사용하기

다이제스트는 네트워크로 비밀번호를 보내는 대신, 비밀번호를 비가역적으로 뒤섞은 fingerprint, digest요약을 보낸다

클라이언트와 서버는 모두 비밀번호를 알고 있으며, 클라이언트가 보낸 요약이 비밀번호에 알맞게 대응하는지 검사할 수 있다


### 13.1.2 단방향 요약

요약은 ‘정보 본문의 압축'이다. 단방향 함수로 동작하고 입력 가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환한다

인기 있는 함수인 MD5는 임의의 바이트 배열을 원래 길이와 상관없이 128비트 요약으로 변환한다

만약 비밀번호를 모른다면 서버에게 보내줄 알맞은 요약을 추측하기 위해 많은 시간을 소요하게 되며, 요약을 갖고 있다면 요약을 생성하는 것을 찾기 위해 많은 시간을 소요하게 된다

요약 함수는 보통 암호 체크섬(cryptographic checksums)으로 불리며, 단방향 해시 함수이거나 지문 함수(fingerprint function)이다


### 13.1.3 재전송 방지를 위한 난스(nonce) 사용

중간자가 만약 요청을 가로채서 서버로 계속 재전송을 한다면 의미가 없는데, 이를 위해 nonce라는 특별하고 자주 바뀌는 증표를 건네준다

nonce와 비밀번호를 섞어 요약을 바뀌게 만들어주는데, 그럴 경우 재전송에 대한 대첵이 가능하다

다이제스트 인증은 nonce를 사용하도록 요구하며, WWW-Authenticate 인증 요구에 담겨 서버가 넘겨준다


### 13.1.4 다이제스트 인증 핸드셰이크

…

---

## 13.2 요약 계산


### 13.2.1 요약 알고리즘 입력 데이터
- 단방향 해시 함수 `H(d)`와 요약 함수 `KD(s,d)`. s는 secret, d는 data 이다
- 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리 = A1
- 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리 = A2


### 13.2.2 H(d)와 KD(s,d) 알고리즘

MD5, MD5-sess(’sess’ = session)을 지원하며, 기본 값은 MD5이다
- H(d) = MD5(d)
- KD(s, d) = H(연결(s:d))


### 13.2.3 보안 관련 데이터 (A1)

A1는 사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보로 이뤄어져 있다

요약을 계산하기 위해 사용되며, 각 알고리즘에 따라 계산할 수 있는 방법이 다르다
- MD5 → A1 = <사용자>:<영역>:<비밀번호>
- MD5-sess → A1 = MD5(<사용자>:<영역>:<비밀번호>):<난스>:<c난스>


### 13.2.4 메시지 관련 데이터 (A2)

URL, 요청 메서드, 메시지 엔터티 본문과 같은 메시지 자체의 정보를 나타낸다

요약을 계산하기 위해 사용되며, 보호 수준(quality of protection; qop)에 따라 두 가지 사용법이 존재한다
- qop = auth(기본) → A2 = <요청메서드>:<uri 지시자 값>
- qop = auth-int → A2 = <요청메서드>:<uri 지시자 값>:H(<요청 엔터티 본문>)

uri 지시자 값은 요청 URI로 반드시 요청 URI와 일치해야 한다


### 13.2.5 요약 알고리즘 전반

요약을 계산하는 두가지 방법이 존재한다

-   qop 옵션이 빠졌을 때 사용되며, 비밀 정보와 난스가 붙은 데이터의 해시를 이용해 요약을 계산한다
-   난스횟수(nc) 집계 및 대칭 인증의 지원을 포함하여, qop가 ‘auth’, ‘auth-int’ 둘다 사용된다


### 13.2.6 다이제스트 인증 세션

어떤 보호 공간을 위한 WWW-Authenticate 인증요구에 대한 클라이언트 응답은, 고악ㄴ에 대한 인증 세션을 시작하게 한다

인증 세션은 클라이언트가 보호 공간의 다른 서버로부터 도 다른 WWW-Authenticate 인증 요구를 받을때까지 지속된다

nonce가 만료되면, 서버는 포함된 nonce 값이 오래된 것일 수 있음을 감수하고 받아들이거나, 다시 요청을 보내도록 401 응답을 반환할 수 있다

이 때 “stale=true”를 정의하면 클라이언트에게 이름과 비밀번호를 다시 받을 수 않고, 새로운 nonce 요청을 보내라고 한다


### 13.2.7 사전(preemptive) 인가

만약 클라이언트가 다음 난스가 무엇이 될지 알고 있다면, 물어보기 전에 Authorization 헤더를 생성할 수 있고, 요청/인증 요구 사이클은 생략될 수 있다

사전 인가는 기본 인증에서 사소하고 흔한 일이지만, 다이제스트 인증에서는 약간 더 복잡하다

서버에서 임의의 난스를 생성하기 때문에, 클라이언트는 무엇이 올바른 Authorization 헤더인지 알 수 없다

하지만 클라이언트가 WWW-Authenticate 인증요구를 기다리지 않고 올바른 nonce를 취득할 수 있는 방법이 있다
- 서버가 다음 nonce를 Authentication-Info 성공 헤더에 담아서 미리 보낸다
- 서버가 짧은 시간 동안 같은 난스를 재사용한느 것을 허용한다
- 클라이언트가 서버와 동기화되어 있고 예측 가능한 nonce 생성 알고리즘을 사용한다

**다음 난스 미리 생성하기**
- 서버는 Authentication-Info 성공 헤더를 통해 다음 난스 값을 미리 제공할 수 있다
- Authentication-Info: nextnonce=”<난스 값>”
- 해당 난스를 사용해 클라이언트는 Authorization 헤더를 미리 만들어둘 수 있으며, 요청, 인증요구 사이클에서 벗어날 수는 있다
- 하지만 같은 서버에 다중 요청을 보내는 파이프라이닝 능력은 실질적으로 쓸모 없어지는데, 다음 요청을 보내기 전에 반드시 다음 난스 값을 받아야 하기 때문이다
- 따라서 성능상의 불이익은 더 커진다

**제한된 난스 재사용**
- 난스를 제한적으로 재사용하는 방법이 있다
- 클라이언트는 난스를 미리 알수 있기 때문에 Authorization 헤더와 함께 요청을 발행하여 파이프라이닝 할 수 있다
- 만료되면 401 인증요구를 하게 되고, WWW-Authenticat: Digest realm=”<영역 값>” nonce=”<새 난스 값>” stale=true 로 보내게 된다/
- 난스 재사용 수명은 통제 가능하기 때문에, 취약점과 성능 간의 trade-off가 있을 수 있다
- 추가적으로 카운터 증가나 IP 주소 검사 같이 재전송 공격을 더 어렵게 만들 수 있는 방법이 있지만, 취약점 자체를 제거할 수는 없다

**동기화된 난스 생성**
- 제 3자가 쉽게 에층할 수 없는 공유된 비밀키에 기반하면서 서버가 순차적으로 같은 난스를 생성할 수 있도록 시간적으로 동기화된 난스 생성 알고리즘을 사용하는 것도 가능하다
- 해당 알고리즘은 다이제스트 인증 명세의 범위를 넘어서게 된다


### 13.2.8 난스 선택

nonce 내용은 불트명하고 구현 의존적인데, 성능 수준, 보안, 편의성은 선택에 달려있다

`BASE64(타임스탬프 H(타임스탬프 ”:” ETag “:” 개인키))`

타임 스탬프는 서버에서 생성된 시간 혹은 아무것이나 반복 불가능한 값이면 되고, ETag는 요청한 엔터티에 대한 Etag 헤더값이며, 개인키는 서버만이 알고 있는 값이다

서버는 클라이언트 인증 헤더를 받은 뒤, 해시 부분을 재계산해보고 클라이언트 인증 헤더의 nonce와 일치하지 않거나 타임 스탬프 값이 오래되었다면 요청을 거절한다

ETag를 포함하면 갱신된 리소스에 대한 재요청을 방지한다

재전송 공격을 방지하기 위해, 어떤 구현은 이전에 사용된 난스나 요약을 받아들이지 않도록 결정할 수 있다

혹은 POST, PUT 요청에는 일회성 난스나 요청을 사용하고, GET 요청을 위해 타임스탬프를 사용할 수도 있다


### 13.2.9 상호 인증

RFC 2617은 클라이언트가 서버를 인증할 수 있도록 다이제스트 인증을 확장했다

서버가 공유된 비밀 정보에 근거한 올바른 응답 요약을 생성할 수 있도록, 클라이언트 난스를 제공함으로써 가능하다

이후 서버는 요약을 Authentication-Info 헤더를 통해 클라이언트에 전달한다

해당 상호 인증 방식은 반드시 구현되는 것을 권장하고, qop 지시자가 있을 경우는 항상 수행해야 한다

응답 요약은 메시지 본문 정보가 다르다는 것만 제와하면 요청 요약과 동일한 방법으로 계산할 수 있다

응답에는 HTTP 메서드가 없고, 요청과 응답간의 메시지 데이터가 서로 다르기 때문에 차이가 존재한다

---

## 13.3 보호 수준(Quality of Protection) 향상

qop 필드는 세가지 헤더 WWW-Authenticate, Authorization, Authentication-Info 모두 존재할 수 있다

qop 필드는 어떤 보호기법을 어느 정도로 사용할 것인지 협상할 수 있게 해준다

서버는 WWW-Autenticate 헤더에 qop 옵션을 목록형태로 보내며, 동시에 자신의 요구에도 맞는 것을 선택하여, Authorization 헤더의 qop 필드에 담아 보낸다

기본적으로 두 가지 초기 보호수준 값을 정의하고 있으며, 하나는 인증을 의미하는 ‘auth’이고, 다른 하나는 인증 및 메시지 무결성 보호를 의미하는 ‘auth-int’이다


### 13.3.1 메시지 무결성 보호

무결성 보호가 적용되었을 때(qop=”auth-int”), 계산되는 `H(엔터티 본문)`는 메시지 본문의 해시가 아닌 엔터티 본문의 해시이다

송신자에 의해 전송 인코딩이 적용되기도 전에 먼저 계산되고 그 후 수신자에 의해 제거된다


### 13.3.2 다이제스트 인증 헤더

다이제스트 인증 프로토콜 양쪽 모두 WWW-Authenticate 헤더에 담겨 전달되는 인증 요구와, Authorization 헤더에 담겨 전달되는 인가 응답을 포함한다

다이제스트 인증은 여기에 선택적인 Authentication-Info 헤더를 추가했다

해당 헤더는 3단계 핸드셰이크를 완성하고 다음번 사용할 난스를 전달하기 위해 인증 성공 후에 전송된다

---

## 13.4 실제 상황에 대한 고려


### 13.4.1 다중 인증요구

서버는 한 리소스에 대해 여러 인증을 요구할 수 있다

예를 들면 서버가 클라이언트의 능력을 모를 때, 기본 및 다이제스트 인증요구를 모두 보낼 것이며, 클라이언트에서는 지원 가능한 가장 강력한 인증 메커니즘을 선택한다

사용자 에이전트는 WWW-Authenticate나 Proxy-Authenticate 헤더 필드의 값을 분석할 때 주의를 기울여야 한다

헤더들에 인증요구가 둘 이상 포함되거나 WWW-Authenticate 헤더가 둘 이상 제공될 수 있기 때문이다

다양한 인증 옵션을 제공하는 경우, ‘가장 허약한 연결부분'에 대한 보안 우려가 있다는 것은 명확하다

서버는 기본 인증을 제한적으로만 사용해야 할 것이며, 관리자는 사용자에게 보안 수준이 다른 여러 시스템에서 같은 비밀번호를 사용하는 것의 위험성에 대해 경고해야 한다


### 13.4.2 오류 처리

다이제스트에서의 요청의 요약이 맞지 않으면 로그인이 실패했음을 기록하는 것이 좋다

인증 서버는 ‘uri’ 지시자 가리키는 리소스가 요청줄에 명시된 리소스에 같음을 확인해야 하며, 다를 경우 400 에러를 반환하고 공격의 징후일 수 있기 때문에 로그를 남기는 것도 좋다

해당 필드의 요청 URL과의 중복된 정보는 중간 프락시가 클라이언트의 요청을 변조했을 가능성에 대처할 수 있게 해준다

변형된 요청의 요약을 계산한 결과는 클라리언트가 계산된 요약과 다를것이기 때문이다


### 13.4.3 보호 공간(Protection Space)

영역값은 접근한 서버의 루트 URL과 결합되어 보호 공간을 정의한다

영역은 서버의 보호된 리소스들을 인증제도와 인가 DB둘중 하나를 가진 보호 영역의 집합으로 분할할 수 있게 해주며, 영역 값은 일반적으로 원 서버에 의해 할당되는 문자열로 인증 제도에 추가적인 의미를 더한다

인가 제도는 같지만 영역은 다른, 다중 인증요구가 있을 수 있다

보호 공간은 어떤 자격이 자동으로 적용되는 영역을 결정하며, 이전 요청이 인가되면 정해진 시간 동안 재사용될 것이다

하나의 보호 공간은 서버 밖으로 확장될 수 없다

보호 공간의 구체적인 계산은 인증 메커니즘에 따라 다르다
- 기본 인증: 클라이언트는 요청 URI와 그 하위의 경로는 같은 보호 공간으로 간주한다
- 다이제스트 인증: ‘WWW-Authenticate: domain’ 필드는 더욱 엄밀하게 정의하며, 해당 목록의 모든 URI와 그 하위에 위치한 모든URI은 같은 보호 공간으로 간주한다


### 13.4.4 URI 다시 쓰기

프락시는 가리키는 리소스의 변경 없이 구문만 고쳐서 URI를 다시 쓰기도 한다
- 호스트 명은 정규화되거나 IP 주소로 대체될 수 있다
- 문자들은 “%” escape 형식으로 대체될 수 있다
- 특정 원 서버로부터 가져오는 리소스에 영향을 주지 않는, 타입에 대한 추가 속성이 URI의 끝에 붙거나 중간에 삽입될 수 있다

프락시가 URI를 변경할 수 있는 동시에 다이제스트 인증은 URI 값의 무결성을 검사하므로, 다이제스트 인증은 실패할 수 있다


### 13.4.5 캐시

어떤 공유 캐시가 Authorization 헤더를 포함한 요청과 그에 대한 응답을 받은 경우, 다음 두 Cache-Control 지시자 중 하나가 응답에 존재하지 않을 경우, 응답을 반환해서는 안된다
- 원서버의 응답이 ‘must-revalidate’ Cache-Control 지시자를 포함한 경우, 캐시는 응답의 엔터티를 다음 요청에 대한 응답을 위해 활용하지만, 먼저 원 서버가 새 요청을 인증할 수 있도록, 헤더를 이용해서 재검사를 수행해야 한다
- 원서버의 응답이 ‘public’ Cache-Control 지시자를 포함할 경우, 응답 엔터티는 임의의 요청에 대한 응답으로 반환될 수 있다

---

## 13.5 보안에 대한 고려사항


### 13.5.1 헤더 부당 변경

헤더 부당 변경에 대해 항상 안전 시스템을 제공하기 위해, 양 종단 암호화나 헤더에 대한 디지털 서명이 필요하다

다이제스트 인증은 쉽게 조작할 수 없는 인증 제도를 제공하느 것에 초점을 맞추고 있으나 반드시 데이터에까지 보호를 확장하는 것은 아니다

보호 수준에 대한 정보는 WWW-Authenticate와 Authorization 헤더에만 담겨있다


### 13.5.2 재전송 공격

폼 데이터를 전송할 때(POST, PUT) 이전에 사용했던 자격을 재사용해도 문제없이 동작하면 안된다

서버가 재전송된 자격을 승인해버리면, 같은 nonce 값을 반복해서 사용한 것이라는 말이다

해당 문제를 완화시키려면 클라이언트의 IP 주소, 타임스탬프, 리소스의 ETag, 개인 서버 키에 대한 요약을 포함하는 난스를 서버가 생성하도록 하는 것이다

하지만 해당 방법의 결점으로는, 난스 생성 시에 클라이언트 IP를 사용하면, 같은 사용자로부터 오더라도 다른 프락시를 통과하게 되는 경우 사용할 수 없으며 IP 주소를 속이는 것도 쉽다

따라서 완전히 공격을 피하려면 매 트랜잭션마다 유일한 nonce 값을 사용하는 것이며, 발급된 난 값은 당시의 트랜잭션과 타임아웃 값의 기간동안만 유효하다


### 13.5.3 다중 인증 메커니즘

서버가 다중 인증제도를 지원할 때, WWW-Authenticate 헤더를 통해 선택지를 제공하지만, 클라이언트에게 강한 인증을 사용하도록 강제되지 않는다

따라서 클라이언트가 가장 강한 인증 제도를 선택하도록 하는 방법, 또는 가장 강력한 인증 제도만을 유지하는 프락시 서버를 사용하면 된다

하지만 사내 네트워크 같이 강력한 인증 제도를 지원할 수 있다는 것을 아는 환경에서만 사용가능하다


### 13.5.4 사전(dictionary) 공격

전형적인 비밀번호 추측 공격으로 트랜잭션을 엿들은 뒤, 난스/응답 쌍에 대해 흔히 구할 수 있는 비밀번호 추측 프로그램을 사용할 수 있다

만약 사용자가 단순한 비밀번호를 사용하고 서버도 단순한 nonce를 사용하고 있다면 맞는 것을 찾을 확률이 꽤 된다

따라서 크래킹하기 어렵도록 복잡한 비밀번호를 사용하며, 비밀번호 만료 정책을 세우는 것이 좋다


### 13.5.5 악의적인 프락시와 중간자 공격 (Man-in-the-Middle Attack)

많은 프락시들이 중간에 존재하며, 그 중 하나가 악의적이거나 보안이 허술하면 중간자 공격에 취약해질 수 있다

프락시의 신뢰도에 흠집을 낼 수 있는 것은 프락시 자신의 확장 인터페이스이다

프락시는 정교한 프로그래밍 인터페이스를 제공하므로, 프락시들을 이용하는 확장을 작성하여 트래픽을 가로채 수정하는 것은 가능하다

하지만 데이터 센터의 보안과 프락시 자체가 제공하는 보안은 악의적 플러그인을 통한 중간자 공격 가능성을 희박하게 한다

도청에 대해 방어할 수 있는 유일한 방법은 SSL을 사용하는 것이다


### 13.5.6 선택 평문 공격

보안이 허술하거나 악의적인 프락시가 트래픽 중간에 끼어든다면 어렵지 않게 ‘클라이언트가 응답 계산을 하기 위한 nonce’를 얻을 수 있다

응답을 계산하기 위해 키를 사용하는 것은 응답 암호 해독을 쉽게 하며, 선택 평문 공격이라 불린다

**미리 계산된 사전 공격**
- 사전 공격과 선택 평문 공격의 조합으로, 미리 결정된 난스와 자주 쓰이는 비밀번호들로 응답의 집합을 생성하고 사전을 만든다
- 이 후에, 공격 서버는 미리 결정된 난스를 클라이언트로 전송하기 시작한다
- 클라이언트로부터 응답을 받을 때, 공격자는 대응되는 항목을 생성한 사전에서 찾는다
- 만약 찾는다면 사용자의 비밀번호를 얻은 것이다

**자동화된 무차별 대입 공격**
- 자동화된 무제한 공격의 차이점은 비밀번호의 계산에 있다
- 미리 계산된 요약을 맞춰보려 시도하는 대신, 많은 컴퓨터를 동원해서 가능한 모든 비밀번호를 열거한다
- 이런 공격은 쉽게 방어할 수 있는데, 클라이언트가 서버에서 제공된 난스 대신에 선택적인 c난스 지시자를 사용하여 응답을 생성할 수 있도록 설정하는 것이다
- 또한 강력한 비밀번호를 강제하는 정책과 좋은 비밀번호 만료 메커니즘이 더해지면, 위협은 완전히 경감시킬 수 있다


### 13.5.7 비밀번호 저장

유닉스 장치의 전통적인 비밀번호 파일과 달리, 다이제스트 인증 비밀번호 파일이 유출되면 영역내 모든 문서는 노출된다

해당 문서에 대한 완화 방법은 여러 가지가 있다
- 비밀번호 파일이 평문으로 된 비밀번호를 포함하고 있다고 생각하고 안전하게 보호한다
- 영역 이름이 유일함을 보장하며, 비밀번호 파일이 유출되더라도 피해를 특정 영역으로 국소화 한다