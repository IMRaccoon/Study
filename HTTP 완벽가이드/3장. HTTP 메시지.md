## 3.1 메시지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다


### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다

HTPP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다

메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것, 사용자 에이전트로 다시 돌아오는 것은 아웃바운드로 이동하는 것이다


### 3.1.2 다운스트림으로 흐르는 메시지

요청 메시지, 응답 메시지와 관계없이 모든 메시지는 다운스트림으로 흐른다

발송자는 수신자의 업스트림이다

---

## 3.2 메시지의 각 부분

HTTP 메시지는 단순한, 데이터의 구조화된 블록이다

각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함한다

시작줄과 헤더는 줄 단위로 분리된 아스키 문자열이다

각 줄은 캐리지 리턴과 개행문자로 구성된 두 글자의 줄바꿈 문자열로 끝난다

엔티티 본문이나 메시지 본문은 단순히 선택적인 데이터 덩어리이다

본문은 시작줄이나 헤더와 달리 텍스트나 이진 데이터를 포함할 수도 있고 그냥 비어있을 수도 있다


### 3.2.1 메시지 문법

모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다

두 메시지는 기본적으로 구조가 같다

요청 메시지 형식

```
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
```

응답 메시지 형식

```
<버전> <상태코드> <사유 구절>
<헤더>

<엔터티 본문>
```

**메서드**
- 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작. GET, POST HEAD …

**요청 URL**
- 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL 경로 구성요소

**버전**
- 메시지에서 사용 중인 HTTP의 버전
- HTTP/<메이저>.<마이너>

**상태코드**
- 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자
- 각 코드의 첫 번째 자릿수는 상태의 일반적은 분류를 나타낸다

**사유 구절**
- 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구

**헤더들**
- 이름, 콜론(:), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들

**엔터티 본문**
- 임의의 데이터 블록을 포함한다


### 3.2.2 시작줄

**요청줄**
- 요청 메시지의 시작줄에는 서버에게 어떤 동작이 일어나야 하는지 설명해주는 메서드와 대상을 지칭하는 URL이 들어있으며, 클라이언트가 어떤 HTTP 버전으로 말하는지 알려준다

**응답줄**
- 응답 메시지의 시작줄에는 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태코드, 수행 상태에 대해 설명해주는 텍스트 사유구절이 들어있다

**메서드**
요청의 시작줄은 메서드로 시작하며, 무엇을 해야하는지 말해준다
- GET: 서버에서 어떤 문서를 가져온다. 본문 X
- HEAD: 서버에서 어떤 문서에 대해 헤더만 가져온다. 본문 X
- POST: 서버가 처리해야 할 데이터를 보낸다. 본문 O
- PUT: 서버에 요청 메시지의 본문을 저장한다. 본문 O
- TRACE: 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다. 본문 X
- OPTIONS: 서버가 어떤 메서드를 수행할 수 있는지 확인한다. 본문 X
- DELETE: 서버에 문서를 제거한다. 본문 X

**상태코드**
- 클라이언트에게 무엇이 일어났는지 말해준다
- 각 응답 메시지의 시작줄에 담겨 반환되며, 숫자 코드와, 문자열로 되어 있어 사람이 이해하기 쉬운 메시지, 이렇게 두개 모두 반환된다
- 상태 코드들은 세 자리 숫자로 된 코드 값을 기준으로 묶인다

**사유 구절**
- 상태 코드와 일대일로 대응되며, 개발자들이 사용자에게 요청 중에 무슨일이 일어났는지 알려주기 위해 넘겨주는 것이다

**버전 번호**
- HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다
- HTTP 애플리케이션들이 자신이 따르는 프로토콜 버전을 상대방에게 말해주기 위한 수단이다
- 버전번호는 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킨다
- 따라서 버전번호가 HTTP/1.1로 된 응답을 받았을 경우, 응답 프로토콜이 HTTP/1.1 가 아니라, 응답을 보낸 애플리케이션이 HTTP/1.1까지 이해할 수 있다는 것을 말한다


### 3.2.3 헤더

**헤더 분류**
- 일반 헤더: 요청과 응답 양쪽에 모두 나타날 수 있음
- 요청 헤더: 요청에 대한 부가 정보를 제공
- 응답 헤더: 응답에 대한 정보를 제공
- Entity 헤더: 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
- 확장 헤더: 명세에 정의되지 않은 새로운 헤더

**헤더를 여러줄로 나누기**
- 만약 긴 헤더를 여러 줄로 쪼갤 경우, 추가 줄 앞에는 최소 하나의 스패이스 혹은 탭 문자가 와야 한다


### 3.2.4 엔터티 본문

엔터티 본문은 HTTP 메시지의 화물로 여러 종류의 디지털 데이터를 실어 나를 수 있다


### 3.2.5 버전 0.9 메시지

0.9 버전은 HTTP 프로토콜 초기 버전으로, 기존보다 훨씬 단순한 프로토콜로 되어 있다

지나친 수준의 단숨함으로 인해 다양한 상황에 대응할 수 없었다

---

## 3.3 메서드


### 3.3.1 안전한 메서드(Safe Method)

GET과 HEAD메서드는 안전하다고 할 수 있는데, HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다

안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없으며, 순전히 개발자에게 달렸다


### 3.3.2 GET

가장 흔히 쓰이는 메서드로, 리소스를 달라고 요청하기 위해 쓰인다


### 3.3.3 HEAD

정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만 반환한다
-   리소스를 가져오지 안혹도 그에 대해 무엇인가를 알아낼 수 있다
-   응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다
-   헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다


### 3.3.4 PUT

PUT 메서드는 서버가 요청의 본문을 가지고 요청 URL의 이름대로 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다

콘텐츠를 변경할 수 있게 해주기 때문에, PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구할 것이다


### 3.3.5 POST

서버에 입력 데이터를 전송하기 위해 설계되었다


### 3.3.6 TRACE

클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다

Trace 요청은 목적지 서버에서 ‘루프백(loopback)’ 진단을 시작한다

마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 응답을 되돌려준다

클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 보낸 메시지가 망가졌거나, 수정되었는지, 그렇다면 어떻게 변경되었는지 확인할 수 있다

주로 진단을 위해 사용되며, 프락시나 다른 애플리케이션들이 어떤 영향을 미치는지 확인해보고자 할 때도 좋은 도구다

하지만 중간 애플리케이션이 여러 다른 종류의 요청들을 일관되게 다룬다고 가정하는 문제가 있다

예를 들면, 프락시는 POST 요청을 바로 서버로 통과시키는 반면, GET 요청은 웹 캐시와 같은 HTTP 애플리케이션으로 전송한다

Trace 요청은 어떠한 엔터티 본문도 보낼 수 없으며, 응답의 엔터티 본문에는 서버가 받은 요청 그대로 들어있다


### 3.3.7 OPTIONS

OPTIONS 메서드는 웹 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다

여러 이소스에 대해 실제로 접근하지 않고도 어떻게 접근하는 것이 최선인지 확인할 수 있는 수단을 클라이언트 애플리케이션에게 제공한다


### 3.3.8 DELETE

서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다

하지만 삭제가 수행되는 것을 보장하지 못하는데, HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다


### 3.3.9 확장 메서드

확장 메서드는 HTTP/1.1 명세에 정의되지 않는 메서드이다
- LOCK: 리소스를 잠글 수 있게 해준다. 문서를 편집하는 동안 다른 사람이 동시에 같은 문서를 편집하지 못하도록 잠글 수 있다
- MKCOL: 사용자가 문서를 생성할 수 있게 해준다
- COPY: 서버에 있는 리소스를 복사한다
- MOVE: 서버에 있는 리소스를 옮긴다

확장 메서드에 대해서는 관용적인 것이 최고이다

프락시는 알려지지 않은 메서드가 담긴 메시지를 다운스트림 서버로 전달하려고 시도한다

확장 메서드를 다룰 때는 “엄격하게 보내고 관대하게 받아들여라"라는 오랜 규칙에 따르는 것이 가장 좋다

---

## 3.4 상태 코드

HTTP 상태 코드는 크게 다섯가지로 나뉜다

클라이언트에게 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다


### 3.4.1 100-199: 정보성 상태 코드

HTTP/1.1 에서 도입되었다

비교적 새로운 것으로, 복잡함을 감수할 만한 가치가 있는지에 대해 논란이 되고 있다

**클라이언트와 100 Continue**
- 100-continue는 여러 측면에서 최적화를 위한 것이다
- 클라이언트는 100-continue를 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로만 사용해야한다
- 해당 상태에 대한 초창기의 혼란 때문에, 100-continue 값이 담긴 Expect 헤더를 보낸 클라이언트는 서버가 100 Continue 응답을 보내주기만을 기다려서는 안된다
- 약간의 타임아웃 후에 그냥 엔터티를 보내야한다

**서버와 100 Continue**
- 서버가 100-continue 값이 담긴 Expect 헤더를 포함된 요청을 받는다면 100 Continue 응답 혹은 에러 코드로 답해야한다
- 서버는 절대로 100-continue 응답을 받을 것을 의도하지 않은 클라이언테에게 100 Continue 상태 코드를 보내서는 안된다
- 어떤 이유로 응답을 보내기 전에 엔터티의 일부를 수신했다면, 해당 상태 코드를 보낼 필요 없다. 왜냐하면 클라이언트는 계속 전송하기로 결정하였기 때문이다
- 하지만 요청을 끝까지 읽은 후에는 그 요청에 대한 최종 응답을 보내야 한다

**프락시와 100 Continue**
- 클라이언트로부터 100-continue 응답을 의도한 요청을 받은 프락시는 몇 가지 해야 할 일이 있다
- 만약 다음 홉 서버가 HTTP/1.1을 따르거나 혹은 어떤 버전을 따르는지 모른다면, Expect 헤더를 포함시켜서 요청을 다음으로 전달해야 한다
- 만약 다음 홉 서버가 1.1보다 이전 버전의 HTTP를 따르는 것을 알고 있다면, 417 에러로 응답해야 한다
- 만약 프락시가 1.1 이전 버전을 따르는 클라이언트를 대신해서 Expect 헤더와 100-continue 값을 요청에 포함시키기로 결정했다면, 프락시는 100 Continue 응답을 클라이언트에게 전달하면 안된다
- 클라이언트는 어떻게 해야 할지 모를것이기 때문이다


### 3.4.2 200-299: 성공 상태 코드

서버는 대응하는 성공을 의미하는 상태코드 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응한다


### 3.4.3 300-399: 리다이렉션 상태 코드

클라이언트가 관심 있는 리소스에 대해 다른 위치를 사용하라고 말해주거나, 다른 대안 응답을 제공한다

리소스가 옮겨졌다면, 클라이언트에게 리소스가 옮겨졌으며 어디서 찾을 수 있는지 알려주기 위해 상태코드와 Location 헤더를 보낼 수 있다

브라우저가 알아서 새 위치로 이동할 수 있게 해준다

상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다

예를 들어, 리소스에 대한 로컬 복사본이 여전히 최신인지 검사할 수 있다

If-Modified-Since라는 헤더를 통해 활용할 수 있다

일반적으로 HEAD가 아닌 요청에 대해 리다이렉션 상태 코드를 포함한 응답을 할 때, 리다이렉트될 URL에 대한 링크와 설명을 포함시키는 것은 좋은 습관이다

303, 303, 307 코드는 중복되는 부분이 있다
- HTTP/1.0 클라이언트가 POST 요청을 보내고 302 리다이렉트 상태 코드가 담긴 응답을 받으면, Location 헤더에 있는 라디아렉트 URL을 POST가 아닌 GET 요청으로 따라갈 것이다
- 그런데 HTTP/1.1 명세는 위와 같은 리다이렉션을 위해 303 상태 코드를 사용한다
- 따라서 HTTP/1.1 클라이언트의 일시적인 리다이렉트를 위해 302 대신 307 상태코드를 사용한다


### 3.4.4 400-499: 클라이언트 에러 상태 코드

많은 클라이언트 에러가 귀찮게 하지 않고 브라우저에 의해 처리된다


### 3.4.5 500-599: 서버 에러 상태 코드

서버 자체에서 에러가 발생하는 경우에 사용한다

프락시는 클라이언트의 입장에서 서버와 대화를 시도할 때 자주 에러를 만나게 된다

프락시는 문제를 설명하기 위해 5XX 서버 에러 상태 코드를 생성한다

---

## 3.5 헤더

헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다

**일반 헤더(General Headers)**
- 일반 헤더는 클라이언트와 서버 양쪽 모두가 사용된다
- 애플리케이션들을 위해 다양한 목적으로 사용된다

**요청 헤더(Request Headers)**
- 요청 메시지를 위한 헤더다
- 그들은 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공한다

**응답 헤더(Response Headers)**
- 응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있다

**엔터티 헤더(Entity Headers)**
- 엔터티 본문에 대한 헤더를 말한다
- 엔터티 본문에 들어있는 데이터의 타입이 무엇인지 말해줄 수 있다

**확장 헤더(Extension Headers)**
- 개발자들에 의해 만들어졌지만, 승인되지 않은 비표준 헤더이다


### 3.5.1 일반 헤더

메시지가 어떤 종류이든 기본적인 정보를 제공하며 유용하다

Connection, Date, MIME-Version, Trailer chunked transfer, Transfer-Encoding, Upgrade, Via

**일반 캐시 헤더**
- HTTP/1.0은 HTTP 애플리케이션에게 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있게 해주는 최초의 헤더를 도입했다
- 최신 버전의 HTTP는 풍부한 캐시 매개변수의 집합을 가지고 있다
- Cache-Control, Pragma


### 3.5.2 요청 헤더

요청 헤더는 요청 메시지에서만 의미를 갖는 헤더다

최초 발생한 곳에서 누가 혹은 무엇이 그 요청을 보냈는지에 대한 정보나, 클라이언트의 능력에 대한 정보를 준다

서버는 요청 헤더가 준 클라이언트에 대한 정보를 클라이언트에게 더 나은 응답을 주기 위해 활용할 수 있다

Client-IP, From, Host, Referer, UA-Color, UA-CPU, UA-Disp, UA-OS, UA-Pixels, User-Agent

**Accept 관련 헤더**
- 클라이언트는 Accept 관련 헤더들은 이용해 서버에게 무엇을 원하고 할 수 있는지, 원치 않는 것도 알려줄 수 있다
- 서버는 추가 정보들을 활용해서 더 똑똑한 결정을 내릴 수 있다
- Accept, Accept-Charset, Accept-Encoding, Accept-Language, TE

**조건부 요청 헤더**
- 때때로, 클라이언트는 요청에 몇몇 제약을 넣기도 한다
- 조건부 헤더를 사용하면, 서버에게 요청을 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있다
- Expect, If-Match, If-Modified-Since, If-None-Match, If-Range, If-Unmodified-Since, Range

**요청 보안 헤더**
- HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있다
- Authorization, Cookie, Cookie2

**프락시 요청 헤더**
- 프락시가 흔해지면서, 기능을 돕기 위해 몇몇 헤더들이 정의되어 왔다
- Max-Forwards, Proxy-Authorization, Proxy-Connection


### 3.5.3 응답 헤더

응답 메시지는 그들만의 응답 헤더를 갖는다

클라이언트에게 부가 정보를 제공하며, 누가 응답을 보내고 있는지, 능력을어떻게 되는지, 특별한 설명도 제공할 수 있다

Age, Public, Retry-After, Server, Title, Warning

**협상 헤더**
- HTTP/1.1는 서버와 클라이언트가 어떤 표현을 택할지에 대한 협상을 할 수 있도록 지원한다
- Accept-Ranges, Vary

**응답 보안 헤더**
- Proxy-Authenticate, Set-Cookie, Set-Cookie2, WWW-Authenticate


### 3.5.4 엔터티 헤더

요청과 응답 양쪽 모두 엔터티를 포함할 수 있기 때문에, 양 타입의 메시지에 모두 나타날 수 있다

엔터티 헤더는 엔터티와 그것의 내용물에 대한, 타입부터 시작해서 주어진 리소스에 대해 요청할 수 있는 유효한 메서드까지, 광범위한 정보를 제공한다

Allow, Location

**콘텐츠 헤더**
- 엔터티의 콘텐츠에 대한 구체적인 정보를 제공한다
- Content-Base, Content-Encoding, Content-Language, Content-Length, Content-Location, Content-MD5, Content-Rnage, Content-Type

**엔터티 캐싱 헤더**
- 엔터티 캐싱 헤더는 엔터티 캐싱에 대한 정보를 제공한다
- ETag, Expires, Last-Modified