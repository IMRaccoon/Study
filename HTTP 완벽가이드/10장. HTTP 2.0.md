## 10.1 HTTP/2.0의 등장 배경

HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화 되었다

그러다보니 성능이 희생되는데, 커넥션 하나를 통해 요청 하나를 보내고 응답 하나만 받는 HTTP 메시지 교환 방식의 지연이 생긴다

병렬 커넥션이나 파이프라인 커넥션이 도입되었지만 성능 개선에 대한 근본적인 해결책이 되지 못했다

구글에서 개발한 SPDY(스피디) 프로토콜을 기반으로 HTTP/2.0 프로토콜을 설계하기로 결정되었으며, 진행중에 있다

---

## 10.2 개요

HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작하며, 커넥션을 초기화하는 것은 클라이언트이다

요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담기는데, HTTP 헤더는 압축되어 담긴다

프레임들에 담긴 요청과 응답은 스트림을 통해 보내지며, 한 개의 스트림이 한 쌍의 요청과 응답을 처리한다

하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있기 때문에, 여러 요청과 응답을 동시에 처리하는 것도 가능하며 흐름 제어와 우선순위 부여 기능도 제공한다

HTTP/2.0은 기존 요청-응답과는 약간 다른 새로운 상호작용 모델인 서버 푸시를 도입했다

이를 통해 서버는 클라이언트에게 필요하다고 생각하는 리소스라면 능동적으로 클라이언트에게 보내줄 수 있다

또한 호환성을 최대한 유지하기 위해, 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지하고 있다

---

## 10.3 HTTP/1.1과의 차이점


### 10.3.1 프레임

HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다

모든 프레임은 8바이트 크기의 헤더로 시작하며, 최대 16383 바이트 크기의 페이로드가 온다

프레임 헤더의 각 필드는 다음과 같다
- R: 예약된 2비트 필드. 반드시 0이어야 하며 받는 쪽은 이 값을 무시해야 한다
- 길이: 14비트 무부호 정수로 길이를 타나태며, 프레임 헤더는 포함되지 않는다
- 종류: 프레임의 종류
- 플래그: 8비트 플래그로 값의 의미는 프레임의 종류에 따라 다르다
- R: 예약된 1비트 필드로 첫번째 R과 마찬가지로 반드시 0이어야 하며, 받는 쪽은 값을 무시한다
- 스트림 식별자: 31비트 스트림 식별자로 0은 커넥션 전체와 연관된 프레임임을 의미한다


### 10.3.2 스트림과 멀티플렉싱

스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 양방향 시퀀스이다

한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진 뒤, 스트림이 닫히게 된다

HTTP/1.1 에서는 한 TCP 커넥션을 통해 요청을 보내고, 응답이 도착해야만 다시 요청을 보낼 수 있었고, 회전 지연을 줄이기 위해 여러 개의 커넥션을 만들어 동시에 요청을 보냈다

하지만 커넥션을 무한정 만들 수 없으며, 한 페이지에 보내야할 요청이 수십~수백에 달하기 때문에 회전 지연이 늘어나는건 피할 수 없다

하지만 HTTP/2.0 에서는 하나의 커넥션에서 여러 개의 스트림이 동시에 열릴 수 있으며, 여러 개의 요청이 동시에 보내질 수 있어 문제가 쉽게 해결된다

뿐만 아니라 우선순위를 가지기 때문에 중요한 리소스에 더 높은 우선순위를 부여할 수 있다 (하지만 우선순위가 의무사항은 아니기때문에 그에 따라 처리된다는 보장은 없다)

모든 스트림은 31비트의 무부호 정수로 된 고유 식별자를 찾는다

스트림이 클라이언트에 의해 초기화되었다면 반드시 홀수여야 하며, 서버라면 짝수여야 한다

또한 새로운 스트림 식별자는 이전에 만들어졌거나 예약된 스트림들의 식별자보다 커야 한다

서버와 클라이언트는 스트림을 협상 없이 일방적으로 만들기 때문에 스트림을 만들때 사용하던 TCP 패킷을 주고 받을 필요 없다

HTTP/2.0 커넥션에서 한 번 사용한 스트림 식별자는 다시 사용할 수 없다

커넥션을 오래 사용하다보면 스트림에 할당할 수 있는 식별자가 고갈되기도 하는데, 이 때는 다시 커넥션을 맺는다


### 10.3.3 헤더 압축

헤더의 크기가 점차 커지면서, 기존에 압축없이 보내는 방식은 불필요한 영향을 미치게 된다

이를 위해 HTTP/2.0은 HTTP 메시지의 헤더를 압축하여 전송한다

헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤, ‘헤더 블록 조각'들로 쪼개져서 전송된다

받는쪽은 조각들을 이은 뒤 압축을 풀어 원래의 헤더 집합으로 복원한다


### 10.3.4 서버 푸시

HTTP/2.0은 서버가 하나의 요청에 대한 응답으로 여러 리소스들을 보낼 수 있도록 한다

해당 기능은 서버가 클라이언트의 요구를 미리 알 수 있을 때 유용하며, 미리 서버가 관련된 리소스를 미리 전송한다

이는 클라이언트가 HTML 문서를 파싱해서 필요한 리소스를 다시 요청하면서 발생하는 트래픽과 회전 지연을 줄여준다

리소스를 푸시하려는 서버는 클라이언트에게 푸시할 것임을 PUSH_PROMISE 프레임을 보내어 미리 알려준다

클라이언트가 해당 프레임을 받은 경우, 해당 프레임의 스트림은 예약된 상태가 된다

이 상태에서 클라이언트가 푸시를 거절하려면 RST_STREAM 프레임을 보낼 수 있으며, 보내게 되면 스트림은 닫히게 된다

먼저 PUSH_PROMISE 프레임을 보내는 이유는 서버가 푸시하려고 하는 자원을 클라이언트가 별도로 요청하게 되는 상황을 피하기 위함이다

서버 푸시를 사용할 때는 다음을 주의해야 한다
- 서버 푸시를 사용하기로 했어도, 중간의 프락시가 서버로부터 받은 추가 리소스를 전달하지 않을 수 있으며, 반대로 프록시가 혼자 클라이언트에게 추가 리소스를 전달할 수도 있다
- 서버는 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시를 할 수 있다
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관되어야 하며, 서버가 보내는 PUSH_PROMISE 프레임은 원 요청을 위해 만들어진 스트림을 통해 보내진다
- 클라이언트는 반드시 서버가 푸시한 리소스를 Same-Origin Policy에 따라 검사해야 한다
- 마지막으로, 서버 푸시를 끄고 싶다면 SETTING_ENABLE_PUSH을 0으로 설정하면 된다

---

## 10.4 알려진 보안 이슈


### 10.4.1 중재자 캡슐화 공격 (Intermediary Encapsulation Attacks)

HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1로 변환할 때 메시지의 의미가 변질될 수 있다

HTTP/1.1 과 다르게 헤더 필드의 이름과 값을 바이너리로 인코딩하며, 어떤 문자열이든 사용할 수 있게 해준다

따라서 정상적인 HTTP/2.0 요청이나 응답이, 위조된 HTTP/1.1 메시지로 번역되는 것을 유발할 수 있다


### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

클라이언트와 서버간의 긴 커넥션은 개인정보의 유출에 악용될 가능성이 있다

어떤 사용자가 브라우저를 사용할 때, 그 사용자는 이전에 그 브라우저를 사용했던 사용자가 무엇을 했는지 알아낼 가능성도 있다