리다이렉션은 보통 메시지가 프락시, 캐시, 서버 팜의 특정 웹 서버 중 어디에서 끝나는지 판별하기 위해 사용한다

클라이언트의 메시지를 명시적으로 요청하기 않은 곳으로 보낼 수 있다

## 20.1 왜 리다이렉트인가?

웹 콘텐츠는 흔히 여러 장소에 배포되는데, 이럴 경우 요청 실패시 다른 곳을 사용할 수 있어 신뢰성이 높아진다

또한 클라이언트가 가까운 리소스에 접근하여 응답시간을 줄여줄 수 있다

목적지 서버가 분산되므로 혼잡도가 줄어든다

리다이렉션의 구현에는 부하 균형의 과제가 포함된다

-   리다이렉션 장치들은 몇 가지 방식의 부하 균형을 포함한다
-   즉, 들어오는 메시지의 부하를 서버들의 집합에게 분산할 수 있다
-   반대의 경우도 마찬가지로 부하 균형이든 리다이렉션을 포함하게 된다
-   들어오는 메시지는 무조건 부하를 공유하는 서버들 중 하나에게 전달되어야 하기 때문이다

## 20.2 리다이렉트 할 곳

서버, 프락시, 캐시, 게이트웨이 모두 클라이언트 입장에서는 서버라고 할 수 있다

모두 공통적으로 서버의 특성을 갖고 있기 때문에, 많은 리다이렉션 기법이 동작하게 된다

-   웹 서버는 IP 별로 요청을 다룬다
    -   같은 URL에 대해 여러 곳에서 온 요청들을 각각 최적의 웹 서버로 보낸다
-   프락시는 프로토콜별로 요청을 다룬다
    -   이상적으로, 모든 HTTP 트래픽은 프락시를 거쳐야 한다
    -   프락시로의 리다이렉트는 주 진입로의 트래픽을 근처에 있는 지름길로 빨아들이는 것과 같다

## 20.3 리다이렉션 프로토콜의 개요

리다이렉션의 목표는 HTTP 메시지를 가용한 웹 서버로 가급적 빨리 보내는 것이다

-   브라우저 애플리케이션의 사용자는 브라우저가 클라이언트 메시지를 프락시 서버로 보내도록 설정할 수 있다
-   DSN 분석자는 메시지의 주솔르 지정할 때 사용될 아이피 주소를 선택한다
-   메시지는 주소가 지정된 여러 개의 패킷으로 나뉘어 네트워크를 통과한다
-   웹 서버는 HTTP 리다이렉트를 이용해 요청이 다른 웹 서버로 가도록 할 수 있다

위의 네 가지는 모두 메시지를 리다이렉트하는 메커니즘을 제공한다

-   대부분의 기법들이 트래픽이 보내려는 곳이 어떤 서버냐에 상관없이 사용될 수 있다
-   하지만 브라우저 설정은 프락시로 향하는 리다이렉트 트래픽에 대해서만 사용할 수 있다

## 20.4 일반적인 리다이렉션 방법

### 20.4.1 HTTP 리다이렉션

웹 서버들은 다른 곳에 요청을 보내보라고 하는 짧은 리다이렉트 메시지를 클라이언트에게 돌려줄 수 있다

-   몇몇 웹 사이트들은 HTTP 리다이렉션을 이용해 간단하게 부하를 분산한다
-   요청을 처리하는 서버는 가용한 것들 중 가장 부하가 적은 서버를 찾아 요청을 전달한다

HTTP 리다이렉션이 갖는 장점으 리다이렉트를 하는 서버가 클라이언트의 아이피 주소를 안다는 것이다

-   이럴 경우 정보에 근거해 선택할 수 있다

HTTP 리다이렉션은 서버로 향하는 요청의 방향을 변경할 수 있지만, 단점이 있다

-   어떤 서버로 리다이렉트할지 결정하려면 원 서버는 상당히 많은 처리를 해야한다
-   페이지에 접근할 때마다 두 번의 왕복이 필요하기 때문에, 사용자가 더 기다리야 한다
-   만약 리다이렉트 서버가 고장나면 사이트도 고장난다

이러한 단점으로 인해 HTTP 리다이렉션은 몇몇 다른 리다이렉션 기법과 함께 조밯하여 사용한다

### 20.4.2 DNS 리다이렉션

DNS는 하나의 도메인에 여러 아이피 주소가 결부되는 것을 허용한다

-   DNS 분석자는 여러 아이피 주소를 반환하도록 설정되거나 프로그래밍 될 수 있다
-   분석자가 어떤 아이피 주소를 반환할 것인지를 결정하는 방법은 단순한 것부터 복잡한 것까지 다양하다

**_DNS 라운드 로빈_**

-   가장 흔하며 단순한 리다이렉션 기법이다
-   웹 서버 팜 전체에 대한 부하 균형을 유지하기 위해 DNS 호스트명 분석 기능을 사용한다
-   서버에 대한 클라이언트의 상대적인 위치나 서버의 현재 스트레스를 고려하지 않는다

**_다중 주소와 라운드 로빈 주소 순환_**

-   대부분의 DNS 클라이언트는 그냥 다중 주소 집합의 첫 번째 주소를 사용한다
-   부하 균형을 위해, 대부분의 DNS 서버는 룩업이 끝났을 때마다 주소를 순환시킨다

**_부하 균형을 위한 DNS 라운드 로빈_**

-   대부분의 DNS 클라이언트는 첫 번째 주소를 사용하기 때문에, 서버들 간의 부하균형을 유지해준다
-   만약 DNS가 주소를 순환시키지 않는다면, 대부분의 클라이언트가 첫번째 서버를 선택할 것이고, 그 서버가 대부분의 부하를 받게 될 것이다

**_DNS 캐싱의 효과_**

-   DNS 주소 순환은 부하를 순환시키는데, 완벽하지 않다
-   자식 DNS으로 인해 기억되어 재사용하게 되는데, 그럴경우 호스트 하나에 한번 DNS 룩업을 하고 주소를 다시 사용한다
-   DNS 룩업 비용이 줄어드는 이익 뿐만 아니라, 같은 클라이언트와 계속 대화하는 것을 선호하는 서버들도 있기 때문이다
-   따라서 라운드 로빈 방식은 좋지 못하다

**_다른 DNS 기반 리다이렉션 알고리즘_**

-   몇몇 향상된 DNS 서버는 주소의 순서를 결정하기 위해 다른 기법들을 사용한다
-   부하 균형 알고리즘: 웹 서버의 로드를 추적하고 가장 로드가 적은 웹 서버를 가장 위에 놓는다
-   근접 라우팅 알고리즘: 웹 서버들의 팜이 지리적으로 분산되어 있을 경우, DNS 서버는 사용자를 근처의 웹 서버로 보내는 시도를 한다
-   결함 마스킹 알고리즘: 네트워크의 건강 상태를 모니터링하고 요청을 정전이나 기타 장애를 피해서 라우팅 할 수 있다

### 20.4.3 임의 캐스트 어드레싱

여러 지리적으로 흩어진 웹 서버들은 같은 아이피 주소를 가지고 클라이언트로에게 가장 가까운 서버로 보내주기 위해 라우터의 최단거리 라우팅 능력에 의지한다

-   이 방법이 동작하는 방식은 웹 서버에게 자신을 인접한 백본 라우터를 향하는 라우터라고 광고하는 것이다

임의 캐스트 어드레싱은 여전히 실험적인 기법이다

-   서버는 반드시 라우터의 언어로 말해야 하고
-   라우터는 일어날 수 있는 주소 충돌을 반드시 다룰 수 있어야 한다

### 20.4.4 아이피 맥 포워딩

이더넷 네트워크에서 HTTP 메시지는 주소가 붙은 데이터 패킷의 형태로 보내진다

-   각 패킷은 출발지와 목적지의 아이피 주소와 TCP 포트번호로 이루어진 레이어-4 주소를 갖고 있다
-   각 패킷은 또한 레이어-2 장비가 주의를 기울여야 하는 MAC 주소도 있다
-   레이어-2 장비의 역할은 들어오는 특정 MAC 주소의 패킷을 받아서 특정 맥 주소로 포워딩하는 것이다

레이어-4를 이해하는 스위치는 레이어-4 주소를 검사하여 라우팅을 할 수 있다

일반적으로 요청한 HTTP 콘텐츠가 캐시 안에 있고 신선하다면 프락시 캐시는 그것을 제공한다

-   그렇지 않다면 프락시 캐시는 클라이언트를 대신해 HTTP 요청을 원 서버로 보낸다
-   스위치는 프락시로부터의 80번 포트 요청을 인터넷 게이트웨이로 보낸다

### 20.4.5 아이피 주소 포워딩

스위치나 다른 레이어 4를 이해하는 장비는 들어오는 패킷에 대해 TCP/IP 어드레싱을 검증하고 패킷을 목적지 아이피 주소의 변경에 따라 라우팅한다

-   맥 포워딩보다 좋은 점 하나는 목적지 서버가 한 홉 거리에 있을 필요가 없다는 것이다
-   스위치에서 업스트림의 위치를 판별할 수만 있다면 일반적인 레이어-3 종단간 인터넷 라우팅이 패킷을 올바른 위치로 보내준다
-   이러한 종류를 네트워크 주소 변환(NAT)이라고 불린다

라우팅 대칭성이라는 문제가 있다

-   클라이언트로부터 들어오는 TCP 커넥션을 받아주는 스위치는 그 커넥션을 관리하고 있다
-   스위치는 반드시 그 응답을 보내주어야 하며, 목적지 서버나 프락시로부터의 모든 응답은 해당 스위치로 가야한다

응답의 귀환 경로를 제어할 수 있는 두 가지 방법은 다음과 같다

-   패킷의 출발지 아이피 주소를 스위치 주소로 바꾼다
    -   스위치와 서버 사이의 네트워크 설정과 관계없이, 응답 패킷을 스위치로 가 한다
    -   목적지와 출발지 아이피 주소 양쪽을 번역해주는 아이피 전달 장치를 NAT라고 한다
-   만약 출발지 아이피 주소가 클라이언트의 아이피 주소로 남아있다면, 서버에서 클라이언트로 바로 가는 경로가 없어야 한다
    -   Half NAT라고 불리며, 서버가 클라이언트 아이피 주소를 얻는 장점이 있다

### 20.4.6 네트워크 구성요소 제어 프로토콜

네트워크 구성요소 제어 프로토콜(Network Element Control Protocol, NECP)은 아이피 패킷을 전달하는 라우터나 스위치 같은 네트워크 구성요소(NE)들이 웹 서버 같은 애플리케이션 계층 요청을 처리하는 서버 구성요소(SE)들과 대화할 수 있게 해준다

NECP는 부하균형을 명시적으로 지원하지 않는다

-   하지만 SE는 NE에게 부하 균형 정보를 제공할 수 있는 방법을 제공한다
-   SE가 적합하다고 판단한 대로 NE가 부하 균형을 유지할 수 있도록 한다
-   포트 포워딩, GRE 캡슐화, NAT와 같은 패킷을 전달하는 여러 방법을 제공한다

NECP는 예외에 대한 개념을 지원한다

-   SE는 특정 출발지 아이피 주소가 서비스 할 수 없다고 판단할 수 있으며, 그 경우 그 주소들을 NE로 보낼 수 있다
-   그러면 NE는 그 아이피 주소로부터 요청을 원 서버로 전닳라 수 있다

## 20.5 프락시 리다이렉션 방법

웹 브라우저와 같은 클라이언트가 프락시로 가는 길을 아는 방법으로는 세가지가 있다

-   명시적인 브라우저 설정
-   동적인 자동 설정
-   자연스러운 가로채기

프락시는 클라이언트의 요청을 다른 프락시로 리다이렉트 할 수 있다

-   클라이언트가 리소스를 요청하는 곳과는 다른 곳에서 응답이 오도록 하게 하는 것이다

### 20.5.1 명시적 브라우저 설정

대부분의 브라우저에는 프락시 서버에 접촉하기 위해 프락시 이름, 아이피 주소, 포트번호를 설정할 수 있는 풀다운 메뉴가 존재한다

몇몇 서비스 제공자들은 미리 설정이 다 되어 있는 브라우저를 다운 받도록 한다

몇시적인 브라우저 설정에는 두 가지 단점이 있다

-   프락시들을 사용하도록 설정된 브라우저들은 프락시가 응답하지 않을 경우 원 서버와 접촉하지 않는다
    -   만약 프락시가 다운되었거나 브라우저가 잘못 설정되었다면, 접속 문제를 경함할 것이다
-   네트워크 아키텍처를 변경했을 때 그 변경사항을 모든 최종사용자에게 전파하는 것이 어렵다
    -   서비스 제공자가 더 많은 프락시를 추가하기 원하거나 줄이기를 원한다면, 사용자가 설정을 변경해야 한다

### 20.5.2 프락시 자동 설정

특정 프락시에 접촉하기 위한 브라우저의 명시적인 설정은 네트워크 아티텍쳐 변화를 제한한다

-   브라우저에 직접 설정을 변경하는 주체가 사용자이기 때문이다

올바른 프락시 서버에 접속하기 위해 브라우저가 동적으로 자신을 설정할 수 있게 하는 자동 설정 방법은 프락시 자동설정(Proxy Auto-configuration, PAC) 프로토콜이라 한다

-   PAC의 기본 아이디어는, 브라우저들이 URL별로 접촉해야 할 프락시를 지정한 PAC 파일이라 불리는 특별한 파일을 찾는다
-   PAC 파일을 얻기 위해 지정된 서버에 접촉하도록 설정되어야 하며, 브라우저는 재시작할 때마다 PAC 파일을 가져온다

PAC 프로토콜은 상당히 강력하다

-   자바스크립트 프로그램은 브라우저에게, DNS 주소나 서브넷, 심이저 요일이나 시각과 같은 호스트명과 관련된 여러 매개변수에 근거하여 프락시를 선택하도록 요구할 수 있다
-   프락시의 위치가 변경된 경우 PAC 파일이 서버에서 업데이트되기 때문에 브라우저가 올바른 프락시에 접촉할 수 있게 해준다

### 20.5.3 웹 프락시 자동발견 프로토콜(Web Proxy Autodiscovery Protocol)

웹 프록시 자동발견 프로토콜(WPAD)은 최종 사용자가 수동으로 프락시 설정을 할 필요가 없다

-   웹 브라우저가 근처의 프락시를 찾아내어 사용할 수 있게 해주는 방법을 제공하는 것을 목적으로 하고 있다
-   일반적인 문제로는 선택할 수 있는 발견 프로토콜이 여러 가지로 존재한다는 것과 프락시 사용에 대한 설정이 브라우저들마다 차이가 있다는 것이다

**_PAC 파일 자동발견_**

-   WPAD는 HTTP 클라이언트가 PAC 파일의 위치를 알아내고 파일을 이용해 적절한 프락시 서버의 이름을 알아낼 수 있게 해준다
-   직접적으로 프락시 서버의 이름을 알아내지는 않는다, 그 이유는 PAC 파일에 의헤 제공되는 추가적인 기능들이 활용될 수 없기 때문이다

WPAD 프로토콜을 구현한 HTTP 클라이언트는 다음의 일을 한다

-   WPAD를 이용해 PAC 파일 CURL을 찾는다
-   URL에 해당하는 PAC 파일을 가져온다
-   프락시 서버를 알아내기 위해 그 PAC 파일을 실행한다
-   PAC 파일이 반환한 프락시 서버에게 HTTP 요청을 보낸다

**_WPAD 알고리즘_**

-   WPAD는 적절한 PAC 파일 CURL을 결정하기 위해 여러 가지 리소스 발견 기법들을 사용한다
-   WPAD 클라이언트는 CURL을 얻는데 성공할 때까지 각각의 기법을 하나씩 시도한다
-   오늘날의 WPAD 명세는 다음의 기법을 순서대로 정의하고 있다
    -   DHCP(Dynamic Host Configuration Protocol, 동적 호스트 설정 프로토콜)
    -   SLP(Service Location Protocol, 서비스 위치 프로토콜)
    -   DNS에게 잘 알려진 호스트명
    -   DNS의 SRV 레코드
    -   TXT 레코드의 DNS 서비스 URL들
-   WPAD 클라이언트는 위의 메커니즘을 사용해 리소스 발견 요청을 순서대로 보낸다
    -   클라이언트들은 그들이 지원하는 매커니즘만 시도한다
-   PAC 파일이 CURL에서 발견되지 못할 경우, 실패하고 클라이언트는 프락시 서버를 사용하지 않는 것으로 설정된다

**_DHCP를 이용한 CURL 발견_**

-   이 메커니즘이 동작하려면, WPAD 클라이언트가 질의하는 DHCP 서버는 반드시 CURL을 저장해야 한다
-   WPAD 클라이언트가 자신의 초기화 과정에서 이미 DHCP 질의를 했다면, DHCP 서버는 이미 그 값을 제공했을 수 있다

**_DNS A 레코드 룩업_**

-   알맞은 프락시 서버의 IP 주소들이 WPAD 클라이언트들이 질의할 수 있는 DNS 서버에 반드시 저장되어 있어야 한다
-   WPAD 클라이언트는 A 레코드 룩업을 DNS 서버로 보내 CURL을 얻으며 성공 시 프락시 서버의 IP 주소를 얻는다

**_PAC 파일 가져오기_**

-   한번 후보 CURL이 생성되면, 보통 그 CURL로 GET 요청을 만드는데, 적절한 CFILE 포맷 정보가 담긴 Accept 헤더를 포함해야 한다

**_언제 WPAD를 실행하는가_**

-   웹 프락시 자동발견 프로세스는 적어도 아래의 상황에서는 수행되어야 한다
    -   웹 클라이언트가 시작될 때
    -   클라이언트 호스트 아이피 주소가 변경된 네트워킹 스택으로부터 언급이 있을 때마다
-   PAC 파일이 만료되었을 때, 클라이언트는 그에 따라 WPAD 프로세스를 재시작해야 한다

**_WPAD 스푸핑(spoofing)_**

-   WPAD의 IE 5 구현은 사용자의 개입 없이 웹 클라이언트가 프락시 설정으로 자동으로 탐지하는 것을 가능하게 했다

**_타임아웃_**

-   WPAD는 여러 발견 단계를 거치며, 클라이언트는 각 단계가 일정한 시간 내에 끝나는지 반드시 확인해야 한다
-   네트워크 특성에 맞는 적절한 값을 선택하는 것이 좋다

**_관리자를 위한 고려사항_**

-   클라이언트들이 호환을 위해 반드시 구현해야 하는 것은 DHCP와 DNS A 레코드 검색 뿐이다
-   관리자들도 둘 중 하나를 설정해야 한다
-   또한 검색 순서에서 이 메커니즘을 먼저 지원하도록 설정하기까지 한다면 클라이언트가 시작하는데 걸리는 시간은 더욱 단축된다
-   WPAD 프레임워크에서 '근접성'을 결정할 때 다음과 같은 가능성들을 고려할 수 있다
    -   DHCP 서버들은 서브넷에 따라 다른 답을 돌려줄 수 있다
    -   DNS 서버는 도메인 접미사에 따라 다른 리소스 레코드를 반환하도록 설정할 수 있다
    -   CURL 요청을 다루는 웹 서버는 User-Agent 헤더, Accept 헤더, 클라이언트 아이피 주소/서브넷/호스트명, 인근 프락시 서버들의 위상기하학적 배치 등에 근거하여 결정을 내릴 수 있다
    -   PAC 파일은, 여러 대안 중 하나를 클라이언트에서 실시간으로 선택할 수 있을 만큼 충분한 표현력을 갖고 있을 수도 있다

## 20.6 캐시 리다이렉션 방법

### 20.6.1 WCCP 리다이렉션

웹 라우터들이 웹 트래픽을 프락시 캐시로 리다이렉트 할 수 있게 하기 위해 캐시 조직 프로토콜(WCCP)를 개발했다

-   라우터들과 캐시들 사이의 대화를 관리하여 라우터가 캐시를 검사하고, 특정 종류의 트래픽을 특정 캐시로 보낼 수 있게 해준다

**_WCCP 리다이렉션 동작_**

-   네트워크가 필요하며, WCCP를 사용할 수 있는 라우터와, 다른 캐시와 의사소통할 수 있는 캐시가 포함되어야 한다
-   라우터들의 집합과 그들의 대상이 되는 캐시들이 WCCP 서비스 그룹을 구성한다
-   만약 서비스 그룹이 HTTP 트래픽을 리다이렉션하도록 설정되어 있다면, 서비스 그룹의 라우터는 HTTP 요청을 서비스 그룹의 캐시로 보낸다
-   HTTP 요청이 서비스 그룹의 라우터에 도착했을 때, 라우터는 그 요청을 처리하기 위해 캐시를 선택한다
-   라우터는 요청 패킷을, 캐시의 아이피 주소와 함께 캡슐화하거나 맥 포워딩을 하여 캐시로 보낸다
-   캐시가 요청을 처리할 수 없다면, 평범하게 포워딩 되기 위해 라우터로 돌아온다
-   서비스 구룹의 구성원들은 지속적으로 가용성을 서로 확인하기 위해 하트비트 메시지를 교환한다

**_메시지 구성요소_**

-   WCCP2 메시지는 헤더와 구성요소로 구성되어 있다
-   각 구성요소는 그 구성요소의 종류와 길이를 서술하는 4바이트 헤더로 시작한다

**_서비스 그룹_**

-   서비스 그룹은 WCCP를 지원하여, WCCP 메시지를 교환할 수 있는 라우터와 캐시들의 집합으로 구성된다
-   라우터들은 웹 트래픽을 서비스 그룹의 캐시로 보낸다
-   서비스 구룹의 설정은 어떻게 트래픽이 서비스 그룹의 캐시들로 분산되는지 결정한다

**_GRE 패킷 캡슐화_**

-   WCCP를 지원하는 라우터들은 HTTP 패킷을 특정 서버의 IP 주소와 함께 캡슐화하여 리다이렉트한다
-   패킷 캡슐화는 일반 라우터 캡슐화(Generic Router Encapsulation, GRE)임을 나타내는 IP 헤더 proto 필드도 포함하고 있다
-   패킷이 캡슐화되어 있기 때문에 아이피 주소를 잃어버리지 않는다

**_WCCP 부하 균형_**

-   특정 수신 서버가 하트비트 메시지를 보내지 않는다면, 해당 노드로 리다이렉트하는 대신 인터넷으로 보낸다
-   노드가 정상화면 WCCP 라우터는 다시 하트비트 메시지를 받고 트래픽을 보낸다

## 20.7 인터넷 캐시 프로토콜

인터넷 캐시 프로토콜(ICP)는 캐시들이 형재 캐시에서 일어난 캐시 적중을 찾아볼 수 있도록 해준다

-   만약 캐시가 요청받은 콘텐츠를 갖고 있지 않다면, 형재 캐시를 확인해보고 해당 캐시에서 콘텐츠를 가져온다
-   한 차례 이상의 ICP 질의를 통해 HTTP 요청 메시지의 최종 목적지를 결정할 수 있다

ICP는 객체 발견 프로토콜이다

-   근처의 캐시 모두에게 특정 URL을 갖고 있는지 한번에 물어본다
-   있을 경우 물어본 캐신느 이웃 캐시에 대한 HTTP 커넥션을 열 수 있다

다음은 ICP 메시지의 각 부분에 대한 설명이다

-   OP 코드: ICP 메시지의 의미를 서술하는 8비트 값
-   버전: 8비트 버전번호는 ICP 프로토콜의 버전 번호를 서술한다
-   메시지 길이: 메시지의 총 길이를 바이트 단위로 나타낸 것
-   요청 번호: ICp를 지원하는 캐시는 동시에 여러 욫어과 응답을 추적하기 위해 요청 번호를 사용한다
-   옵션: 32비트 ICP 옵션 필드는 ICP의 동작을 변경한느 플래그를 담고 있는 비트 백터이다
-   옵션 데이터: 32비트 옵션 데이터는 옵션 기능을 위해 예약되어 있다
-   발송자 호스트 주소: 메시지 발송자의 32비트 아이피 주소를 담고 있다
-   페이로드: 페이로드의 콘텐츠는 메시지의 형태에 따라 달라진다

## 20.8 캐시 배열 라우팅 프로토콜

프락시 서버는 인터넷으로 향하는 트래픽을 대폭 줄여준다

-   하지만 사용자가 증가하면, 프락시 서버 자체에 과도한 부하가 생긴다
-   이를 위해 프락시 서버를 여러 대로 늘리는 것이다

캐시 배열 라우팅 프로토콜(CARP)은 프락시 서버의 배열이 클라이언트 시점에서는 하나의 논리적인 캐시처럼 보이도록 관리해준다

-   ICP의 대안이다

CARP는 각 구성요소 서버가 전체 캐시된 문서의 일부만 갖고 있는 하나의 큰 서버처럼 동작한다

-   웹 객체의 URL에 해시 함수를 적용함으로써, 특정 프락시 서버에 매핑한다
-   하나의 웹 객체는 하나의 프락시 서버에만 속하여, 모두를 폴링하지 않고도 한 번의 검색으로 위치를 결정할 수 있다

CARP에서 프락시 서버 분석이 결정론적이라는 것은 질의를 모두 보낼 필요 없다는 것이며, 주고 받는 메시지가 더 적음을 말한다

-   더 많은 서버가 설정에 추가되어도 문제가 없다
-   하지만 프락시 서버 중 하나가 사용할 수 없게 되면, 해시 함수가 수정되어야 하고, 콘텐츠들도 다시 배치되어야 한다
-   따라서 고장이 잦다면 비용이 비싸진다

CARP 리다이렉션 방법은 다음의 작업을 포함한다

-   참여하는 프락시 서버의 테이블을 유지한다
-   각 참여 프락시 서버들에 대해 해시 함수를 계산한다
-   요청된 웹 객체의 URL에 근거한 숫자값을 반환하는 분리된 해시 함수를 정의한다
-   URL의 해시 함수와 프락시 서버의 해시 함수의 함계로 값의 배열을 얻는다

위의 작업들은 브라우저에 의해 수행될 수도 있고, 중간 서버에 의해 계산될 수도 있다

프락시 서버들의 각 무리는 해당 무리의 모든 서버를 나열하는 테이블을 생성한다

-   테입르의 각 엔트리는 부하 인자에 대한 정보, 생존시간 카운트 다운 값, 구성원들이 얼마자 자주 폴링되어야 하는 지 등에 대한 매개변수를 포함해야 한다
    -   부하 인자는 장비의 부하 능력을 명시한다
-   테이블은 RPC 인터페이스를 통해 원격으로 관리될 수 있다
    -   테이블의 필드들이 RPC에 의해 갱신되면, 필드들은 사용될 수 있게 되거나 다운 스트림의 클라이언트들에게 배포된다
    -   HTTP 에 의해 배포가 수행되므로 쉽게 테이블의 정보를 사용할 수 있다

## 20.9 하이퍼텍스트 캐싱 프로토콜

하이퍼텍스트 캐싱 프로토콜(Hyper Text Caching Protocol, HTCP)은 형제들이 URL과 모든 요청 및 응답 헤더를 사용하여 서로에게 문서의 존재 여부에 대한 질의를 할 수 있도록 해준다

-   따라서 잘못 적중 처리되어 잘못 처리될 가능성을 줄인다
-   또한 HTCP는 형제 캐시들이 서로의 캐시 안에 있는 선택된 문서의 추가 및 삭제를 모니터링하고 요청할 수 있게, 그리고 서로의 캐시된 문서에 대한 캐싱 정책을 변경할 수 있게 해준다

HTCP 메시지의 헤더는 메시지의 길이와 메시지의 버전을 퐇마하고, 데이터 부분은 OP 코드를 퐇마한 데이터의 길이로 시작하여, 응답 코드, 몇몇 태그들과 아이디들이 이어지며 실제 데이터로 끝난다

-   헤더: 헤더 영역은 32비트 메시지 길이, 8비트 주 프로토콜 버전, 8비트 부 프로토콜 버전으로 이루어진다
-   데이터: HTCP 메시지를 포함한다

### 20.9.1 HTCP 인증

-   인증 길이: 메시지의 인증 영역이 몇 바이트인지 담고 있는 16비트 숫자이다
-   Sig 길이: 서명이 생성된 시각을 세계 표준시 이후로 경과된 초 단위의 시간으로 표현한 32비트 숫자
-   Sig 만료: 서명이 만료될 시각을 세계 표준시 이후로 경과된 초 단위의 시간으로 표현한 32비트 숫자
-   키 값: 공유된 비밀의 이름을 담은 문자열
-   서명: 출발지와 목적지 아이피 주소와 포트, 메시지의 주/부 HTCP 버전, Sig 시간과 만료 값, 전체 HTCP 데이터, 키에 대한 HMAC-MD5 요약으로 64의 B 값을 갖는다

### 20.9.2 캐싱 정책 설정

-   Cache-Vary: 요청자는 콘텐츠가 응답 Vary 헤더의 집합과 다른 헤더의 집합에 따라 달라지며, 응답 Vary 헤더를 덮어쓴다
-   Cache-Location: 프락시 캐시의 목록은 객체의 사본을 가질 수도 있다
-   Cache-Policy: 캐시 가능하지 않지만 공유 가능함을 말하는 'no-cache', 공유할 수 없는 객체임을 의미하는 'no-share', 권하지 않음을 의미하는 'no-cache-cookie'가 있다
-   Cache-Flags: 요청자는 객체의 캐싱 정책을 수정했으며, 객체는 특별히 취급되어야 할 수 있다
-   Cache-Expiry: 문서의 실제 만료 일시
-   Cache-MD5: 요청자가 계산한 객체의 MD5 체크섬
-   Cache-to-Origin: 요청자가 계산한 원 서버로의 왕복 시간
