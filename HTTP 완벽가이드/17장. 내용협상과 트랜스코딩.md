HTTP는 클라이언트와 서버 간에 여러 리소스 중 선택할 수 있는 내용 협상 방법을 제공한다

또한 서버는 특정 URL에 대해 어떤 콘텐츠가 가장 적합한지에 대한 다른 판단도 할 수 있어야 한다


## 17.1 내용 협상 기법

서버에 있는 페이지들 중 어떤 것이 클라이언트에게 맞는지 판단하는 세가지 방법이 있다
- 클라이언트 주도
	- 클라이언트가 요청을 보내면, 서버는 클라이언트에게 선택지를 보내주고, 클라이언트가 선택한다
	- 서버 입장에서는 구현하기 가장 쉽고, 클라이언트는 최선의 선택을 할 수 있다
	- 올바른 콘텐츠를 얻기 위해 최소 두 번의 요청이 필요하기 때문에 대기시간이 증가한다
- 서버 주도
	- 서버가 클라이언트의 요청 헤더를 검증해서 어떤 버전을 제공할지 결정한다
	- 클라이언트 주도 협상보다 빠르다
	- 만약 헤더에 맞는 것이 없다면, 서버는 추측을 해야만 한다
- 투명
	- 투명한 중간 장치(주로 프락시 캐시)가 서버를 대신하여 협상한다
	- 웹 서버가 협상할 필요가 없으며, 클라이언트 주도 협상보다 빠르다
	- 투명 협상을 어떻게 하는지에 대한 정형화된 명세가 없다

---

## 17.2 클라이언트 주도 협상

서버에게 있어 가장 쉬운 방법은 클라이언트의 요청을 받았을 때 가능한 페이지의 목록을 응답으로 돌려주어, 클라이언트가 원하는 것을 선택하도록 하는 것이다

서버 입장에서는 가장 구현하기 쉽지만, 각 페이지에 두 번의 요청이 필요하며 오래 걸린다

기술적으로, 서버가 클라이언트에게 줄 선택지를 표현하는 방법은 두 가지가 있다
- 여러 가지 버전에 대한 링크와 각각에 대한 설명이 담긴 HTML을 돌려준다
- 300 Multiple Choices 응답 코드로 HTTP/1.1 응답을 돌려준다

증가된 대기시간과 페이지당 여러 번의 요청이 필요하다는 단점이 있다

또 다른 단점으로는 여러 개의 URL을 요구하게 된다는 것이 있다

---

## 17.3 서버 주도 협상

클라이언트가 서버에게 선호하는 것에 대해 충분한 정보를 전달하여 현명한 결정을 할 수 있게 해준다

서버는 해당 정보를 클라이언트의 요청 헤더에서 얻는다

HTTP 서버가 클라이언트에게 보내줄 적절한 응답을 계산하기 위해 사용하는 매커니즘은 두가지이다
- 클라이언트의 내용 협상 헤더인 Accept 관련 헤더들을 보고 그에 맞는 응답 헤더를 준비한다
- 내용 협상 헤더 이외의 다른 헤더들을 살펴본다


### 17.3.1 내용 협상 헤더

클라이언트는 아래의 헤더들을 이용해 선호 정보를 보낸다
- Accept: 서버가 어떤 미디어 타입으로 보내도 되는지 알려준다
- Accept-Language: 서버가 어떤 언어로 보내도 되는지 알려준다
- Accept-Charset: 서버가 어떤 차셋을 보내도 되는지 알려준다
- Accept-Encoding: 서버가 어떤 인코딩으로 보내도 되는지 알려준다

위의 헤더들과 일치하는 엔터티 헤더들은 아래와 같다
- Accept: Content-Type
- Accept-Language: Content-Language
- Accept-Charset: Content-Type
- Accept-Encoding: Content-Encoding

HTTP는 상태가 없는 프로토콜이기 때문에, 클라이언트는 자신의 선호 정보를 반드시 매 요청마다 보내야 한다

만약 클라이언트에서 서버가 알아볼 수 없는 헤더를 보내는 것을 방지하기 위해 선호 정보를 추가하여 보낼 수 있다


### 17.3.2 내용 협상 헤더의 품질값

HTTP 프로토콜은 클라이언트가 각 선호의 카테고리마다 여러 선택 간으한 항목 선호도와 함께 나열할 수 있도록 품질값을 정의하였다

q값은 0.0부터 1.0까지 값을 가질 수 있다

때때로 클라이언트 선호 문서에 대해 서버가 하나도 없을 수 있다

이에 대해 서버는 문서를 고치거나 트랜스코딩할 수 있다


### 17.3.3 그 외의 헤더들에 의해 결정

서버는 User-Agent와 같은 클라이언트의 다른 요청 헤더들을 이용해 알맞은 요청을 만들기 위해 시도할 수 있다

그 외 헤더들에 대한 최적의 'q' 값은 없기 때문에, 정확한 대응을 찾아내거나 갖고 있는 것을 주어야 한다

캐시는 반드시 캐시된 문서의 올바른 '최선의' 버전을 제공해주려 해야하기 때문에 HTTP 프로토콜은 서버가 응답에 넣어 보낼 수 있는 Vary 헤더를 정의한다

Vary 헤더는 캐시에게 서버가 내줄 응답의 최선의 버전을 결정하기 위해 어떤 헤더를 참고하고 있는지 말해준다


### 17.3.4 아파치의 내용 협상

아파치 웹서버가 내용협상을 지원하는 방법은 다음과 같다
- 내용 협상은 웹 사이트 콘텐츠의 제공자에게 달려있다
- 만약 색인 페이지를 여러 가지 버전을 제공하고 싶을 경우, 각각의 버전에 해당하는 파일들을 아파치 서버의 디렉토리에 넣어주어한다
- 그런 다음 둘 중 하한가지 방법으로 내용협상을 동작시킨다
	- 웹 사이트 디렉토리에서, varant를 갖는 웹사이트의 각 URI를 위한 type-map 파일을 만든다
		- 해당 type-map 파일은 모든 배리언트와 그들 각각에 대응하는 내용 협상 헤더들을 나열한다
	- 아파치가 그 디렉토리에 대해 자동으로 type-map 파일을 생성하도록 하는 지시어를 켠다

**type-map 파일 사용하기**
- 서버 설정 파일에 type-map 파일들을 위한 파일 접미사를 명시한 핸들러를 추가한다
- type-map 파일을 통해, 내용협상을 수행한다

**MultiViews 사용하기**
- MultiViews를 사용하려면, access.conf 파일의 적절한 절에 Options 지시어를 이용해야 한다
- 만약 켜져있을 경우, 리소스 요청에 대해 파일들을 살펴보고 type-map을 생성한다


### 17.3.5 서버 측 확장

서버에서 내용 협상을 구현하는 또 다른 방법으로, ASP과 같이 서버 쪽에서 확장하는 방법이 있다

---

## 17.4 투명 협상

투명 협상은 클라이언트 입장에서 협상하는 중개자 프락시를 둠으로써 메시지 교환을 최소화한다

또한 서버 주도 협상으로 인한 부하를 서버에서 제거한다

프각시는 클라이언트의 기대가 무엇인지 알고 있고, 클라이언트 입장에서 협상을 수행할 수 있는 능력이 있는 것으로 가정된다

투명한 내용 협상을 지원하기 위해, 클라이언트의 어떤 헤더를 검사해야하는지 프락시에게 말해주어야 한다

HTTP/1.1 명세에서는 투명 협상에 대해 Vary 헤더를 정의했다

서버는 응답에 Vary 헤더를 포함시켜 보내어, 중계자에게 어떤 헤더를 사용하고 있는지 알려준다

캐시 프락시는 단일한 URL을 통해 접근할 수 있는 문서의 여러 사본을 저장할 수 있다

캐시 안에 설치되어 있는 범용 트랜스코더는 특정 서버에 국한되지 않고 어떤 서버의 콘텐츠든 트랜스코딩할 수 있다


### 17.4.1 캐시와 얼터네이트(alternate)

콘텐츠를 캐시하는 것은 재사용될 것이라 예상하기 때문이다

캐시는 클라이언트에게 응답을 돌려주기 위해, 서버가 응답을 돌려줄때 사용한 의사결정 로직의 상당부분을 그대로 사용해야 한다


### 17.4.2 Vary 헤더

서버가 어떤 페이지를 반환할 것인지 판단하기 위해 다른 헤더들을 사용하고 있을 수 있다

캐시는 반드시 그 헤더들이 무엇인지 알아야 하며, 캐시된 페이지 중 어떤 것을 반환할지 선택할 때 서버가 했던 것과 동일한 로직을 적용해야 한다

HTTP Vary 응답 헤더는 서버가 문서를 선택하거나 커스텀 콘텐츠를 생성할 때 고려한 클라이언트 요청 헤더 모두를 나열한다

새 요청이 도착했을 때, 캐시는 내용 협상 헤더들을 이용해 가장 잘 맞는 것을 찾는다

하지만 캐시는 반드시 캐시된 응답 안에 서버가 보낸 Vary 헤더가 들어있는지 확인해야 한다

Vary 헤더가 존재할 경우, 명시하고 있는 헤더들은 새 요처오가 오래된 캐시된 요청과 그 값이 서로 일치해야 한다
- 서버는 클라이언트의 요청 헤더에 따라 응답이 달라질 수 잇다
- 따라서 투명 협상을 구현하기 위해 캐시는 반드시 캐시된 variant와 함께 클라이언트의 요청 헤더와 서버의 응답 헤더 모두를 저장해야 한다


캐시는 각 배리언트마다 알맞은 문서 버전을 저장해야 한다

캐시가 검색을 할 때, 먼저 내용 협상 헤더로 적합한 컨텐츠를 맞춰보고, 다음에 요청의 배리언트를 캐시에 맞춰본다

맞는 것이 없다면 문서를 서버에서 가져온다

---

## 17.5 트랜스코딩

서버가 클라이언트의 요구에 맞는 문서를 아예 갖고 있지 않다면, 기존의 문서를 클라이언트가 사용할 수 있는 것으로 변환할 수 잇다

트랜스코딩에는 포맷 변환, 정보 합성, 내용 주입의 세 종류가 있다


### 17.5.1 포맷 변환

포맷 변환은 데이터를 클라이언트가 볼 수 있도록 한 포맷에서 다른 포맷으로 변환하는 것이다

내용 변환 혹은 트랜스코딩은 콘텐츠 인코딩이나 전송 인코딩과는 다르다는 것에 주의해야 한다


### 17.5.2 정보 합성

문서에서 정보의 요점을 추출하는 것을 정보 합성이라고 하며, 트랜스코딩 과정에서 유용하다

본문의 키워드에 기반하여 페이지를 분류하는 기술은 문서의 핵심을 요약할 때도 유용하다

이 기술은 포털 사이트의 웹사이트 디렉터리와 같은 자동화된 웹페이지 분류 시스템에 의해 종종 사용된다


### 17.5.3 콘텐츠 주입

내용 주입 트랜스코딩은 문서의 양을 늘리며, 자동 광고 생성과 사용자 추적 시스템 등이 있다


### 17.5.4 트랜스코딩 vs 정적으로 미리 생성해놓기

트랜스코딩의 대안은 웹페이지의 여러 사본을 만드는 것이지만, 현실적인 기법이 되지는 못한다

작은 변화에도 많은 것들을 수정해야 하며, 더 많은 공간이 필요하고, 관리하고 제공해주는 서버는 까다로워진다

루트 페이지를 필요할때마다 변환하는 것은 정적으로 미리 생성해 놓는 것보다 더 쉽다

하지만 콘텐츠 제공에 대한 대기시간이 증가하게 된다

몇몇 계산들에 대해 제삼자에게 수행하여 서버의 부담을 덜 수 있으며, 더 싼 프락시나 캐시에 있는 에이전트에 의해 수행될 수 있다

---

## 17.6 다음 단계

내용 협상에 대한 이야기는 다음 두 가지 이유로 Accept나 Content 관련 헤더들에서 끝나지 않는다
- HTTP의 내용 협상은 성능 제약을 초래한다
- HTTP는 내용 협상이 필요한 유일한 프로토콜이 아니다

