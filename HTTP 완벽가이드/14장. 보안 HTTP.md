## 14.1 HTTP를 안전하게 만들기

이전의 기본 인증, 다이제스트 인증, 그리고 메시지 무결성은 충분히 강력하지는 않다

그래서 HTTP 보안 버전을 사용한다


### 14.1.1 HTTPS

HTTP를 안전하게 만드는 방식 중 가장 인기있는 방식으로, HTTPS를 사용하면 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다

HTTP 하부에 전송 레벨에 암호 보안 계층을 추가로 제공하여 동작하며, 안전 소켓 계층(Secure Sockets Layer, SSL) 또는 그를 계승한 전송 계층 보안 (Transport Layer Security, TLS)을 이용하여 구현된다

SSL, TLS은 매우 비슷하다

어려운 인코딩, 디코딩 작업은 SSL 라이브러리 안에서 일어나기 때문에, 기존 HTTP 관련 로직을 수정할 필요 없다

---

## 14.2 디지털 암호학

디지털 암호의 기초 용어
- 암호: 텍스트를 인코딩하는 알고리즘
- 키: 암호의 동작을 변경하는 숫자 매개변수
- 대칭키 암호 체계: 인코딩, 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계: 인코딩, 디코딩에 다른 키를 사용하는 알고리즘
- 공개키 암호법: 비밀 메세지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명: 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서: 신뢰할 만한 조직에 의해 서명되고 검증된 선원 확인 정보


### 14.2.1 비밀 코드의 기술과 과학

암호법은 메시지 인코딩과 디코딩에 대한 과학이자 기술이다

보지 못하도록 암호화하는 것 뿐만 아니라, 메시지의 변조를 방지하기 위함이기도 하다


### 14.2.2 암호 (cipher)

암호는 메시지를 인코딩하는 어떤 특정한 방법과, 그 메시지를 디코딩하는 방법이다


### 14.2.3 암호 기계

암호는 상대적으로 쉬운 알고리즘으로 시작했지만, 점차 기술이 진보하면서 보다 복잡한 암호로 빠르고 정확하게 빠르게 인코딩 디코딩하는 기계를 만들었다


### 14.2.4 키가 있는 암호

대부분의 기계들에는 암호의 동작방식을 변경할 수 있는 큰 숫자로 된 다른 값을 설정할 수 있는 다이얼이 있다

기계를 탈취당해도, 올바른 다이얼 설정(키 값)이 없으면 디코더가 작동하지 않는다

해당 암호 매개변수를 키라고 부른다

암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어주며, 서로 다른 키값을 가지기 때문에 제각각 다르게 동작한다


### 14.2.5 디지털 암호

디지털 계산의 도래로 더욱 복잡한 인코딩과 디코딩 알고리즘이 가능해졌고, 큰 키를 지원할 수 있게 되어 무작위 추측이 어려워졌다

---

## 14.3 대칭키 암호법

대칭키 암호에서, 발송자와 수신자 모두 통신을 위해 비밀 키를 똑같이 공유할 필요가 있다

발송자는 공유된 비밀키를 메시지를 암호화하고 그 결과인 암호문을 수신자에게 발송하기 위해 사용된다

수신자 역시 수신된 암호문을 평문으로 복호화하기 위해 키를 사용하여 해독 함수를 적용한다


### 14.3.1 키 길이와 열거 공격(Enumeration Attack)

대부분의 경우, 인코딩 디코딩 알고리즘은 공개적으로 알려져 있기 때문에 비밀 키가 유일한 비밀이다

따라서 공격자는 무차별로 모든 키값을 대입하고 해당 방식을 열거 공격이라고 한다

가능한 키 값의 개수는 키가 몇 비트이며 얼마나 많은 키가 유효한지에 달려있다

대칭키 암호에서는 모든 키값이 유효하기 때문에 8비트라면 256, 40비트라면 2의 40승(약 1조)가지가 가능하다

하지만 오늘날 빠른 워크스테이션으로 인해 초당 수십억 번의 계산이 가능하기 때문에 1조 종류도 쉽게 깨질 수 있다

128비트 키를 사용한 대칭키 암호는 매우 강력한 것으로 간주한다


### 14.3.2 공유키 발급하기

대칭키 암호의 단점 중 하나는 둘 다 공유키를 가져야 한다는 것이다

하지만 이런 경우, 하나의 서버와 여러 클라이언트들의 관계에서 서버는 모든 클라이언트의 공유키를 관리해야 한다

또한 N개의 노드가 자신을 제외한 N-1 개의 통신이 필요하다면 총 N제곱의 비밀키가 필요하다

---

## 14.4 공개키 암호법

공개키 암호 방식은 두 개의 비대칭 키를 사용한다

하나는 호스트의 메시지를 인코딩하기 위한 것이며, 다른 하나는 그 호스트의 메시지를 디코딩 하기 위한 것이다

인코딩 키는 모두를 위해 공개되어 있지만, 호스트만이 개인 디코딩 키를 가지고 있다

노드 한 개는 자신의 인코딩 키를 공개적으로 배포할 수 있고, 메시지를 해당 노드에게 보내고자 하는 누구나 공개된 공개키를 사용할 수 있다

누구나 사용할 수 있는 인코딩 키가 할당되어 있기 때문에, 공개키 암호방식이 대칭키의 쌍이 폭발적으로 늘어나는 것을 피할 수 있다

인코딩은 누구나 할 수 있지만, 디코딩은 해당 노드만 디코딩 개인키를 가지고 있기 때문에 아무도 할 수 없다

따라서 안전하게 메시지를 발송하는 것을 더 쉽게 해줄 수 있다


### 14.4.1 RSA

공개키 비대칭 암호의 과제는 ‘공개키', ‘네트워크 스누핑으로 통해 얻은 암호문 일부', ‘인코더에 임의의 텍스트를 넣어 만든 암호문'을 알고 있어도 개인키를 계산할 수 없어야 한다

이를 만족하는 유명한 공개키 암호 체계로는 RSA가 있다

RSA 구현 소스코드를 알더라도 암호를 크래킹하여 개인키를 찾아내는 것은 매우 어려운 일이다


### 14.4.2 혼성 암호 체계와 세션 키

공개키 암호 방식의 알고리즘은 계산이 느리다는 단점이 있어, 실제로는 대칭과 비대칭 방식을 섞은 것으로 사용한다

노드들 간의 안전한 의사소통 채널을 수립할 때는 공개키 암호를 사용하고, 안전한 채널을 통해 임시 무작위 대칭키를 생성하여 교환한 뒤에는 대칭키를 사용한다

---

## 14.5 디지털 서명


### 14.5.1 서명은 암호 체크섬이다

디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬이다
- 서명은 메시지를 작성한 저자가 누구인지 알려준다. 저자는 저자의 개인키를 가지고 있기 때문에, 저자만이 체크섬을 계산할 수 있다. 체크섬은 저자의 개인 ‘서명'처럼 동작한다
- 서명은 메시지 위조를 방지한다. 공격자가 송신 중인 메시지를 수정했다면 체크섬은 메시지와 맞지 않게 되고, 체크섬은 저자의 개인키에 관련되어 있기 때문에 침입자는 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없다

디지털 서명은 보통 비대칭 공개키에 의해 생성되는데, 개인키는 소유자만이 알고 있기 때문에 ‘지문'처럼 사용된다

메시지를 받은 쪽에서는 공개키를 사용해 서명을 검사할 수 있다

---

## 14.6 디지털 인증서


### 14.6.1 인증서의 내부

디지털 인증서에는 공식적으로 ‘인증 기관'에 의해 디지털 서명된 정보의 집합이 담겨 있다
- 대상의 이름 (사람, 서버, 조직 등)
- 유효 기간
- 인증서 발급자 (누가 인증서를 보증하는가)
- 인증서 발급자의 디지털 서명

추가적으로 디지털 인증서는 대상과 사용된 서명 알고리즘에 대한 정보 뿐만 아니라 대상의 공개키도 담고 있다

누구나 디지털 인증서를 만들 수 있지만, 널리 인정받는 서명 권한을 얻을 수 있는 것은 아니다


### 14.6.2 X.509 v3 인증서

디지털 인증서에 대한 아직 전 세계적 단일 표준은 없지만, 대부분 X.509라고 불리는 서식에 정보를 저장하고 있다

X.509 v3 인증서는 인증 정보를 파싱 가능한 필드에 넣어 구조화하는 표준화된 방법을 제공한다

X509 기반 인증서에는 웹 서버 인증서, 클라이언트 이메일 인증서, 소프트웨어 코드사인 인증서, 인증기관 인증서를 비롯한 몇 가지 변종이 있다


### 14.6.3 서버 인증을 위해 인증서 사용하기

HTTPS를 통한 안전한 엡 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다

만약 서버에 인증서가 없다면 보안 커넥션은 실패한다

서버 인증서에는 여러 필드들이 존재한다
- 웹 사이트의 이름과 호스트 명
- 웹 사이트의 공개키
- 서명 기관의 이름
- 서명 기관의 서명
- …

브라우저가 인증서를 받으면 서명 기관을 검사하는데, 해당 기관이 신뢰할만하다면 브라우저는 공개키를 이미 알고 있을 것이며 브라우저가 서명을 검증할 수 있다

만약 서명 기관이 모르는 곳이라면, 해당 기관을 신뢰하는지 확인하기 위해 대화상자를 보여준다

---

## 14.7 HTTPS의 세부사항

HTTP는 HTTP의 가장 유명한 보안 버전으로, HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다

HTTPS는 인터넷 애플리케이션의 성장을 가속하면서 동시에 웹 기반 전자상거래의 고속 성장을 이끌었다


### 14.7.1 HTTPS 개요

HTTPS는 보안 전송 계층을 통해 전송되는 HTTP이다

HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보낸다

오늘날 보안 계층은 SSL과 더 현대적인 대체품인 TLS로 구현되었지만, SSL이라고 지칭한다


### 14.7.2 HTTPS 스킴

오늘날 보안 HTTP는 선택적이기 때문에, 웹 요청 시에 서버에게 HTTP 보안 프로토콜 버전을 수행한다고 말해줘야 한다

따라서 ‘http’ 대신 ‘https’으로 URL 스킴 접두사를 수정한다

SSL 트래픽은 바이너리 프로토콜이기 때문에 HTTP와는 완전히 다르며, 80번 포트로 도착하게 된다면 잘못된 HTTP로 해석하고 커넥션을 닫는다

따라서 443 포트를 통해 트래픽이 전달된다


### 14.7.3 보안 전송 셋업

HTTPS는 SSL 보안 계층 때문에 HTTP 보다 복잡하다

HTTPS는 443 포트로 먼저 연결하며 TCP 연결이 되고 나면, 암호법 매개변수와 교환키를 협상하면서 SSL 계층을 초기화한다

핸드셰이크가 완료되면 SSL 초기화가 되며, 요청 메시지를 보안 계층에 보낼 수 있는데, 이 때 메시지는 TCP로 보내지기 전에 암호화된다


### 14.7.4 SSL 핸드셰이크

암호화된 HTTP 메시지를 보낼 수 있게 되기 때문에, SSL 핸드셰이크를 할 필요가 있다

핸드셰이크는 다음과 같은 일이 일어난다
- 프로토콜 버전 번호 교환
- 양쪽에 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성


### 14.7.5 서버 인증서

SSL은 서버 인증서 → 클라이언트, 클라이언트 인증서 → 서버 로 전달해주는 상호 인증을 지원한다

하지만 클라이언트 인증서는 흔히 쓰이진 않으며, 대부분의 사용자는 개인 클라이언트 인증서를 갖고 있지 않다

보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구하는데, 보안 트랜잭션을 수행할 때 해당 조직이 정상적인지 알고 싶을 것이다

따라서 인증기관에 의해 서명된 서버 인증서는 얼마나 신뢰할 수 있는지 평가하는 것을 도와줄 수 있다

서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름 등등을 보여주는 X.509 v3에서 파생된 인증서이다

사용자와 클라이언트 소프트웨어는 믿을 만한 것인지 확인하기 위해 인증서를 검증할 수 있다


### 14.7.6 사이트 인증서 검사

SSL 자체는 웹 서버 인증서를 검증할 것을 요구하지 않지만, 최신 웹 브라우저 대부분은 인증서에 대해 기본적인 검사를 하고 철저한 검사를 할 수 있는 방법을 사용자에게 알려준다

넷스케이프가 제안한 서버 인증서 검사를 위한 알고리즘은 대부분 웹브라우저의 검사 기법의 기초를 구축했다

해당 알고리즘의 수행 단계는 다음과 같다

**날짜 검사**
- 인증서가 여전히 유효함을 확인하기 위해 인증서의 시작 및 종료일을 검사한다
- 만료되었거나 활성화되지 않았다면, 검사는 실패하고 브라우저는 에러를 보여준다

**서명자 신뢰도 검사**
- 모든 인증서는 서버를 보증하는 인증기관(Certifiacte Authority, CA)에 의해 서명되어 있다
- 여러 수준의 인증서가 있으며, 다른 수준의 배경 검증을 필요로 한다
- 누구나 인증서를 생성할 수 있지만 몇몇 CA는 잘 알려진 기관이기 대문에, 브라우저는 신뢰할만한 서명 기관의 목록을 포함한 채로 배포된다
- 만약 알려져있지 않은 인증기관으로 서명한 인증서를 받았을 경우 경고를 보여준다
- 신뢰할만한 CA가 간접적으로 서명한 인증서를 받아들이는 것을 선택할 수 있다

**서명 검사**
- 한번 서명 기관이 믿을만하다고 판단하면, 서명기관의 공개키를 서명에 적용하여 체크섬을 비교하면서 인증서의 무결성을 검사한다

**사이트 신원 검사**
- 서버가 누군가 다른 이의 인증서를 복사하거나 그들의 트래픽을 가로채는 것을 방지하기 위해, 대부분의 브라우저는 인증서 내부의 도메인 이름이 서버의 도메인이 맞는지 검사한다
- 서버 인증서에는 보통 단일 도메인이 들어있지만, 몇몇 CA는 서버 이름의 목록이나 서버 이름에 와일드카드 표현이 들어있는 인증서를 만든다
- 만약 호스트명이 인증서의 신원과 맞지 않는다면, 사용자에게 알리거나 잘못된 인증서 에러와 함께 커넥션을 끊어야 한다


### 14.7.7 가상 호스팅과 인증서

가상 호스트로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운데, 오직 하나의 인증서를 지원한다

만약 인증서의 이름과 맞지 않는 가상 호스트 명에 도착하면 경고가 나타난다

그렇기 때문에 보안 트랜잭션을 시작하는 모든 사용자를 서버 인증서와 일치하는 호스트로 리다이렉트 한다

---

## 14.8 진짜 HTTPS 클라이언트

SSL은 복잡한 바이너리 프로토콜이며, 몇 가지 SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 상용 혹은 오픈 소스 라이브러리를 존재한다


### 14.8.1 OpenSSL

OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈 소스 구현이다

OpenSSL은 SSLeay 라이브러리를 계승하였고, 인터페이스가 매우 비슷하다


### 14.8.2 간단한 HTTPS 클라이언트

…


### 14.8.3 우리의 단순한 OpenSSL 클라이언트 실행하기

SSL 핸드셰이크를 완료되자마자, 클라이언트는 열린 SSL 커넥션을 갖게 된다

클라이언트는 커넥션의 상태와 선택된 매개변수에 대해 물어보고 서버의 인증서를 검증할 수 있다

한번 SSL 채널이 수립되고 클라이언트가 서버 인증서를 받아들이게 되면, 클라이언트는 HTTP 요청을 보안 채널을 통해 전송한다

---

## 14.9 프락시를 통한 보안 트래픽 터널링

클라이언트는 종종 웹 서버에 접근해주는 웹 프락시 서버를 이용한다 (회사와 인터넷을 잇는 경계)

해당 프락시는 방화벽 라우터가 HTTP 트래픽의 교환을 허락한 유일한 장치이며, 바이러스 검사나 컨텐츠 제어를 수행한다

하지만 클라이언트가 서버로 보낼 데이터를 서버 공개키로 암호화한다면, 프락시는 HTTP 헤더를 읽을 수 없다

HTTPS가 프락시와 잘 동작할 수 있게 하기 위해, 어디에 접속하려고 하는지 알려주는 방법을 수정해야 한다

가장 인기있는 방법은 HTTPS SSL 터널링 프로토콜이며, 클라이언트는 먼저 프락시에게 연결하고자 하는 호스트와 포트를 평문으로 말해준다

CONNECT라고 불리는 새로운 확장 메서드를 이용해 프락시에게 호스트와 포트번호로 연결해달라고 전달한다

완료되면, 클라이언트와 서버 간에 데이터를 직접적으로 오갈 수 있게 해주는 터널을 만든다