## 1단계 문제 이해 및 설계 범위 확정

#### 요구사항

-   빠른 응답 속도
-   연관성
-   정렬: 인기도 등의 순위 모델에 의해 정렬
-   규모 확장성
-   고가용성

#### 개략적 규모 추정

-   DAU는 천만명으로 가정한다
-   평균적으로 사용자는 매일 10건의 검색을 수행한다고 가정한다
-   질의할 때마다 평균 20바이트의 데이터를 입력한다고 가정한다
    -   문자 인코딩은 ASCII를 사용한다고 가정하여, 1문자 = 1바이트 이다
    -   질의문은 평균적으로 4 단어로 이루어진다고 가정하고, 각 단어는 평균적으로 다섯 글자로 구성된다고 가정한다
    -   따라서 질의당 평균 4 x 5 = 20 바이트이다
-   검색창에 글자를 입력할때마다 클라이언트는 백엔드에 검색어 자동완성 요청을 보낸다
    -   따라서 1회 검색당 20건의 요청의 백엔드로 전달된다
-   초당 24,000 건의 질의(QPS)가 발생한다 (10,000,000 사용자 _ 10 질의 / 일 _ 20 글자 / 24시간 / 3600 초)
-   최대 QPS는 2배로 가정하여, 약 48,000
-   질의 가운데 20%는 신규 검색어라고 가정하여, 대략 0.4GB 정도의 데이터가 매일 시스템에 추가된다

## 2단계 개략적 설계안 제시 및 동의 구하기

크게 두 부분으로 시스템을 나눌 수 있다

-   데이터 수집 서비스(data gathering service)
    -   사용자가 입력한 질의를 실시간으로 수집하는 시스템이다
    -   데이터가 많은 애플리케이션에 실시간 시스템은 바람직하지 않지만, 초기 아이디어로 채택하고 이후에 교체할 것이다
-   질의 서비스 (query service)
    -   주어진 질의에 다섯 개의 인기 검색어를 정렬해 내놓는 서비스이다

#### 데이터 수집 서비스

질의문과 사용빈도를 저장하는 빈도 테이블이 있다
이를 통해 사용자가 검색하는 내용들을 저장하여 빈도 수를 늘리게 된다

#### 질의 서비스

빈도 테이블에 Query 필드와 Frequency 필드가 있으며, 사용자가 입력한 텍스트를 기반으로 빈도 테이블에 기록된 수치를 사용해 순위를 매겨 반환한다
데이터 양이 적을때에는 나쁘지 않지만, 데이터가 많아지면 병목현상이 발생할 수 있다

## 3단계 상세 설계

#### 트라이 자료구조

RDB를 저장소로 지정했지만, 효율적이지 않다
이는 트라이를 사용해 해결할 수 있다
트라이 자료구조의 핵심 아이디어는 다음과 같다

-   트라이는 트리 형태의 자료구조이다
-   이 트리의 루트 노드는 빈 문자열을 나타낸다
-   각 노드는 글자 하나를 저장하며, 26개의 자식 노드를 가질 수 있다
-   각 트리 노드는 하나의 단어, 또는 접두어 문자열을 나타낸다

트라이로 검색어 자동완성을 구현하기 위해 용어를 먼저 정의한다

-   p: 접두어의 길이
-   n: 트라이 안에 있는 노드 개수
-   c: 주어진 노드의 자식 노드 개수

가장 많이 사용된 질의어 k개는 다음과 같이 찾을 수 있다

-   해당 접두어를 표현하는 노드를 찾는다 (시간 복잡도 O(p))
-   해당 노드부터 시작하는 하위 트리를 탐색하여 모든 유효노드를 찾는다
    -   유효한 검색 문자열을 구성하는 노드가 유효 노드이다 (시간 복잡도 O(c))
-   유효 노드를 정렬하여 가장 인기있는 검색어 k개를 찾는다 (시간 복잡도 O(c logc))

예를 들어 k=2 이고 be라고 검색했을 경우

1. 접두어 노드 be를 찾는다
2. 해당 하위 트리를 탐색하여 모든 유효노드를 찾는다 (be 의 자식 노드 개수만큼 조회)
3. 유효 노드를 정렬하여 2개만 골라낸다 (자식 노드 정렬)

이에 대한 최악의 경우에 k개 결과를 위해 전체 트라이를 다 검색해야 할 수 있으며, 이를 위해 해결방법은 다음과 같다

1. 접두어의 최대 길이를 제한
2. 각 노드에 인기 검색어를 캐시

**접두어 최대 길이 제한**

-   사용자가 검색 창에 긴 검색어를 입력하는 일이 거의 없다
-   p값은 작은 값으로 가정해도 안전하다

**노드에 인기 검색어 캐시**

-   각 노드에 k개의 인기 검색어를 저장해두면 전체 트라이를 검색하는 일을 방지할 수 있다
-   k 수가 적어야 부담이 덜하다
-   각 노드에 질의어를 저장해두어야 한다는 단점이 있지만, 빠른 응답속도를 기대할 수 있다

#### 데이터 수집 서비스

사용자가 검색창에 타이핑을 할 때마다 실시간으로 데이터를 수정하는 것은 실용적이지 않다

-   매일 수천만 건의 질의가 입력될 텐데 그 때마다 트라이를 갱신하면 서비스가 심각하게 느려진다
-   일단 트라이가 만들어지면 인기 검색어는 그다지 자주 바뀌지 않을 것이기 때문에 자주 갱신하지 않아도 된다
    데이터 수집을 위해서는 일단 데이터 분석 서비스나 로깅 서비스로부터 데이터가 오게 된다

**데이터 분석 서비스 로그**

-   검색창에 입력된 질의에 관한 원본 데이터가 보관된다
-   새로운 데이터가 추가되며, 수정은 없고, 로그 데이터에 인덱스를 걸지 않는다

**로그 취합 서버**

-   데이터 분석 서비스의 로그는 양이 많으며 형식도 제각각인 경우가 많아, 이를 잘 취합해서 활용해야 한다
-   취합 방식은 서비스 용례에 따라 달라질 수 있다
-   하지만 대부분의 경우는 일주일에 한 번만 취합해도 된다 (실시간 업데이트 중요도 낮음)

**취합 데이터**

-   매주 취합한 데이터의 결과물로, query와 해당 업데이트 일자, 그리고 frequency를 담고 있는 테이블로 구성된다

**작업 서버**

-   주기적으로 비동기 작업을 실행하는 서버 집합이다
-   트라이 자료구조를 만들고 트라이 DB에 저장하는 역할을 담당한다

**트라이 캐시**

-   분산 캐시 시스템으로, 메모리에 유지하여 읽기 연산 성능을 높이는 역할을 한다
-   매주 트라이 DB의 스냅샷을 떠서 갱신한다

**트라이 데이터베이스**

-   지속성 저장소로 두가지 선택지가 있다
    1. 문서 저장소(document store): 주기적으로 트라이를 직렬화하여 DB에 저장한다 (Mongo DB)
    2. 키-값 저장소: 트라이는 아래의 로직을 적용하여 해시 케이블 형태로 변환할 수 있다
        - 트라이에 보관된 모든 접두어를 해시 테이블 키로 변환
        - 각 트라이에 보관된 모든 데이터를 해시 테이블 값으로 변환

#### 질의 서비스

이전에 인기 검색어 k개를 골라내는 설계안의 개선한 결과이다

1. 검색 질의가 로드밸런서로 전송된다
2. 로드밸런서는 해당 질의를 API 서버로 보낸다
3. API 서버는 트라이 캐시에서 데이터를 가져와 해당 요청에 대한 자동완성 검색어 제안 응답을 구성한다
4. 데이터가 트라이 캐시에 없는 경우 DB에서 가져와 캐시에 채운다

질의 서비스는 최대한 빨라야 하며, 이를 위해 최적화 방안은 아래와 같다

-   AJAX 요청(request)
    -   브라우저는 보통 AJAX 요청을 보내어 자동완성된 검색어 목록을 가져온다
    -   이 방법의 장점은 요청을 보내고 받기 위해 페이지를 새로고침할 필요가 없다는 것이다
-   브라우저 캐싱(browser caching)
    -   자동완성 검색어 제안 결과는 짧은 시간안에 바뀌지 않기 때문에, 해당 결과를 브라우저 캐시에 넣어둘 수 있다
    -   구글 같은 경우는 검색어를 한 시간동안 캐시해둔다
-   데이터 샘플링(data sampling)
    -   대규모 시스템의 경우, 모든 질의 결과를 로깅하도록 해놓으면 CPU 자원과 저장공간을 많이 사용하게 된다
    -   따라서 N개 중 1개만 로깅하도록 한다

#### 트라이 연산

**트라이 생성**

-   작업 서버가 담당하며, 데이터 분석 서비스의 로그나 DB로부터 취합된 데이터를 이용한다

**트라이 갱신**

1. 매주 한 번 갱신하는 방법. 새로운 트라이를 만들고 기존 트라이를 대체한다
2. 트라이의 각 노드를 개별적으로 갱신하는 방법
    - 하지만 성능이 좋지 않으며, 트라이가 작으면 고려해볼만 하다
    - 트라이 노드를 갱신할 때, 모든 상위 노드도 갱신해야 하는데, 상위 노드에도 인기 검색어 질의 결과가 보관되기 때문이다

**검색어 삭제**

-   여러 가지로 위험한 질의어를 자동완성 결과에서 제거해야 한다
-   따라서 트라이 캐시 앞에 필터 계층을 두고 부적절한 질의어가 반환되지 않도록 하면 된다
-   필터 규칙에 따라 검색 결과를 자유롭게 변경할 수 있다는 장점이 있다

#### 저장소 규모 확장

트라이의 크기가 한 서버에 넣기에 너무 큰 경우를 위해 규모 확장성에 대한 문제를 해결해야 한다
첫 글자를 기준으로 샤딩하는 방법이 있다
하지만 최대 26대로 제한된다 (알파벳을 사용할 경우)
만약 더 많은 서버를 필요로 한다면 계층을 한단계 더 나누어야 한다

-   하지만 이런 경우는 균등하게 배분하는데에 어려움이 존재한다
-   이를 위해 질의 데이터의 패턴을 분석하여 샤딩하는 방법을 제안한다
    -   검색어 대응 샤드 관리자가 어떤 검색어가 어떤 저장소 서버에 저장되는 지에 대한 정보를 관리한다

## 4단계 마무리

다국어 지원을 위해서는 트라이에 유니코드 데이터를 저장해야 한다
또한 국가별로 인기 검색어 순위가 다를 경우, 국가별 다른 트라이를 사용하고, 트라이를 CDN에 저장하여 응답속도를 높일 수도 있다
실시간 변동을 위해서는 다음 아이디어들이 있다

-   샤딩을 통해 작업 대상 데이터의 양을 줄인다
-   순위 모델을 바꾸어 최근 검색어에 보다 높은 가중치를 준다
-   데이터가 스트림 형태로 올 수 있다는 점을 고려해야 한다
    -   데이터가 지속적으로 생성되며, 이를 위해서는 특별한 종류의 시스템이 필요로 하다
