## 1단계

기능적 요구사항

-   파일 추가, 가장 쉬운 방법은 파일을 구글 드라이브 안으로 떨구는 방식이다
-   파일 다운로드
-   여러 단말에 파일 동기화. 한 단말에서 파일을 추가하면 다른 단말에도 자동으로 동기화되어야 한다
-   파일 갱신 이력 조회
-   파일 공유
-   파일이 편집되거나 삭제되거나 새롭게 공유되었을 때 알림 표시

비-기능적 요구사항

-   안정성: 데이터 손실이 발생하면 아노디낟
-   빠른 동기화 속도: 파일 동기화 시간이 오래 걸리며 안된다
-   네트워크 대역폭: 대역폭을 불필요하게 많이 소모하면 안된다
-   규모 확장성
-   높은 가용성

#### 개략적 추정치

-   가입 사용자는 5천만명이고 천만명의 DAU가 있다고 가정
-   모든 사용자에게 10GB 무료 저장공간 할당
-   매일 각 사용자가 평균 2개의 파일을 업로드한다고 가정. 각 파일의 평균 크기는 500KB
-   읽기:쓰기 비율은 1:1
-   필요한 저장공간 총량 = 5천만 사용자 x 10GB = 500페타바이트
-   업로드 API QPS = 1천만 사용자 x 2회 업로드 / 24시간 / 3600초 = 약 240
-   최대 QPS = QPS x 2 = 480

## 2단계 개략적 설계안 제시 및 동의 구하기

일단 한대의 서버로 시작한다

-   파일을 올리고 다운로드 하는 과정을 처리할 웹 서버
-   사용자 데이터, 로그인 정보, 파일 정보 등의 메타데이터를 보관할 DB
-   파일을 저장할 저장소 시스템. 파일 저장을 위해 1TB 공간을 사용한다

#### API

1. 파일 업로드 API
    - 단순 업로드: 파일 크기가 작을때 사용
    - 이어 올리기: 파일 사이즈가 크고 네트워크 문제로 업로드 중단 가능성이 높을때 사용
        - 이어올리기는 다음 세 단계로 이루어진다
            1. 이어올리기 URL을 받기 위한 최초 요청 전송
            2. 데이터를 업로드하고 업로드 상태 모니터링
            3. 업로드에 장애가 발생하면 장애 발생시점부터 업로드 재시작
2. 파일 다운로드 API
3. 파일 갱신 히스토리 API

#### 한 대 서버의 제약 극복

파일 시스템이 가득 찰 경우, 데이터를 샤딩하여 여러 서버에 나누어 저장하는 방법이 있다
서버에 장애가 생기면 데이터를 잃게 될 수 있는데, 아마존 S3를 사용하여 저장할 수 있다

-   다중화를 지원하며, 지역 안에서만 다중화를 하는 것도 가능하다

추가적으로 생길 수 있는 제약으로 다음이 있다

-   로드밸런서: 네트워크 트래픽을 위해 사용하며, 트래픽을 고르게 분산해주고, 특정 서버 장애 시 핻당 서버를 우회시켜준다
-   웹 서버: 로드밸런서를 추가한 뒤에, 더 많은 웹 서버를 추가하여 트래픽이 폭증해도 대응이 가능하다
-   메타데이터 DB: 데이터 베이스를 파일 저장 서버에서 분리해 SPOF를 회피하며, 다중화 및 샤딩을 적용하여 가용성과 확장성에 대응한다
-   파일 저장소: S3를 사용하며, 가용성과 무손실을 보장하기 위해 두 개 이상의 지역에 데이터를 다중화한다

#### 동기화 충돌

동시에 업데이트 하는 경우, 먼저 처리되는 변경을 성공으로 하고, 나중에 처리되는 것을 충돌로 표시한다

#### 개략적 설계안

**사용자 단말**

-   사용자가 사용하는 브라우저나 앱 등의 클라이언트

**블록 저장소 서버(block server)**

-   파일 블록을 클라우드 저장소에 업로드하는 서버
-   블록 수준 저장소(block-level storage)라고도 하며, 클라우드 환경에서 데이터 파일을 저장하는 기술
-   파일을 여러 개의 블록으로 나눠 저장하며, 각 블록에는 고유한 해시값이 할당된다
-   해당 해시값은 메타데이터 DB에 저장된다
-   각 블록은 독립적인 객체로 취급되며 클라우드 저장소 시스템에 보관된다
-   파일을 재구성하려면 블록들을 원래 순서대로 합쳐야 한다

**클라우드 저장소**

-   파일은 블록 단위로 나뉘져 클라우드 저장소에 보관된다

**아카이빙 저장소**

-   오랫동안 사용되지 않은 비활성 데이터를 저장하기 위한 컴퓨터 시스템

**로드 밸런서**

-   요청을 모든 API 서버에 고르게 분산하는 구실을 한다

**API 서버**

-   파일 업로드 외에 거의 모든 것을 담당하는 서버이다
-   사용자 인증, 사용자 프로파일 관리, 파일 메타데이터 갱신 등에 사용된다

**메타데이터 데이터베이스**

-   사용자, 파일, 블록, 버전 등의 메타데이터 정보를 관리한다
-   실제 파일은 클라우드에 보관하며, 데이터베이스에는 오직 메타데이터만 둔다

**메타데이터 캐시**

-   성능을 높이기 위해 자주 쓰이는 메타데이터는 캐시한다

**알림 서비스**

-   특정 이벤트가 발생했음을 클라이언트에게 알리는데 쓰이는 발행/구독 프로토콜 기반 시스템이다
-   파일 추가, 편집, 삭제 등을 알려준다

**오프라인 사용자 백업 큐(offine backup queue)**

-   클라이언트가 접속 중이 아니라서 파일의 최신 상태를 확인할 수 없을 때는 해당 정보를 큐에 두어 나중에 클라이언트가 접속하면 동기화할 수 있다

## 3단계 상세 설계

#### 블록 저장소 서버

정기적으로 갱신되는 큰 파일들은 업데이트 마다 전체 파일을 서버로 보내면 대역폭을 많이 사용하게 된다
이를 최적화하는 방법은 다음과 같다

-   델타 동기화(delta sync): 파일이 수정되면 전체 파일 대신 수정이 일어난 블록만 동기화 한다
-   압축(compression)
    -   블록 단위로 압축해두면 데이터 크기를 많이 줄일 수 있다
    -   압축 알고리즘은 파일 유형에 따라 정할 수 있다

파일 업로드에 관계된 일들을 처리하는 컴포넌트이다

-   클라이언트가 보낸 파일을 블록단위로 나누고
-   각 블록에 압축 알고리즘 적용 및 암호화까지 한다
-   전체 파일을 저장소 시스템으로 보내는 대신, 수정된 블록만 전송해야 한다

#### 높은 일관성 요구사항

같은 파일이 단말이나 사용자에 따라 다르게 보이는 것은 허용할 수 없다
메타데이터 캐시와 데이터베이스 계층에도 같은 원칙이 적용되어야 한다
메모리 캐시는 보통 최종 일관성 모델을 지원한다
따라서 강한 일관성을 달성하려면 다음 사항을 보장해야 한다

-   캐시에 보관된 사본과 DB에 있는 원본이 일치한다
-   DB에 보관된 원본에 변경이 발생하면 캐시에 있는 사본을 무효화한다

관계형 DB는 ACID를 보장하므로 강한 일관성을 보장하기 쉽다
하지만 NoSQL은 동기화 로직 안에 프로그래밍해서 넣어야 한다

#### 메타데이터 데이터베이스

-   user: user 테이블에는 이름, 이메일, 프로파일 사진 등 사용자에 관계된 기본적인 정보들이 보관된다
-   device: 단말 정보가 보관된다. push_id 필드를 통해 모바일 푸시 알림을 받을 수 있으며, 한 사용자가 여러 단말을 가질 수 있다
-   namespace: 사용자의 루트 디렉토리 정보가 보관된다
-   file: 파일의 최신정보가 보관된다
-   file_version: 파일의 갱신 이력이 보관되는 테이블로, 읽기 전용으로 하여 갱신 이력이 훼손되지 않는다
-   block: 파일 블록에 대한 정보를 보관하여, 파일 블록을 조합하기만 하면 복원할 수 있다

#### 업로드 절차

-   파일 메타데이터 추가

    1. 클라이언트가 새 파일의 메타데이터를 추가하기 위한 요청 전송
    2. 새 파일의 메타데이터를 데이터베이스에 저장하고 업로드 상태를 대기중으로 변경
    3. 새 파일이 추가되었음을 알림 서비스에 통지
    4. 알림 서비스는 관련된 클라이언트들에게 파일이 업로드되고 있음을 알림

-   파일을 클라우드 저장소에 업로드
    1. 클라이언트가 파일을 블록 저장소 서버에 업로드
    2. 저장소 서버는 파일을 블록 단위로 쪼개고 압축하고 암호화한 다음에 클라우드 저장소에 전송
    3. 업로드가 끝나면 클라우드 저장소는 완료 콜백을 호출하며, API 서버로 전송
    4. 메타데이터 DB에 기록된 해당 파일의 상태를 완료로 변경
    5. 알림 서비스에 파일 업로드가 끝났음을 통지
    6. 알림 시버시는 관련된 클라이언트들에게 파일 업로그가 끝났음을 알림

#### 다운로드 절차

다른 클라이언트가 편집했거나 추가했다는 사실을 감지하는 방법

-   클라이언트가 접속중이고 다른 클라이언트가 파일을 변경하면 알림 서비스가 알려준다
-   클라이언트가 접속중이지 않을 경우, 데이터는 캐시에 저장되며, 클라이언트가 접속하면 새로운 버전을 가져간다

1. 알림 서비스가 클라이언트 2에게 누군가 파일을 변경했음을 알림
2. 알림을 확인한 클라이언트 2는 새로운 메타데이터 요청
3. API 서버는 메타데이터 데이터베이스에 새로운 메타데이터 요청
4. API 서버에게 새 메타데이터 반환
5. 클라이언트 2에게 새 메타데이터 반환
6. 클라이언트 2는 즉시 블록 다운로드 요청 전송
7. 블록 저장소 서버는 클라우드 저장소에서 블록 다운로드
8. 클라우드 저장소는 블록 서버에 요청된 블록 반환
9. 블록 저장소 서버는 클라이언트에게 요청된 블록 반환. 클라이언트 2는 전송된 블록을 사용해 파일 재구송

#### 알림 서비스

롱 폴링을 사용할 건데 이유는 다음과 같다

-   채팅 서비스와 달리, 양방향 통신이 필요하지 않다 (서버에서 클라이언트로의 통신만 필요)
-   웹 소켓은 실시간 양방향 채팅같은 곳에서만 적합하며, 알림을 보낼 일이 자주 발생하지는 않는다

롱 폴링을 쓰게 되면

-   각 클라이언트는 알림 서버와 롱 폴링용 연결을 유지하다가 특정 파일에 대한 변경을 감지하면 연결을 끊는다
-   클라이언트는 이 때에 메타데이터 서버와 연결해 파일의 최신 내역을 다운로드 해야 한다
-   다운로드가 끝났거나 연결 타임아웃에 도달하면 즉시 새 요청을 보내어 롱 폴링 연결을 복원하고 유지한다

#### 저장소 공간 절약

-   중복 제거(de-dupe): 중복된 파일 블록을 계정 차원에서 제거하는 방법으로 해시 값을 통해 비교한다
-   지능적 백업 전략을 도입한다
    -   한도 설정: 보관해야 하는 파일 버전 개수에 상한을 둔다
    -   중요한 버전만 보관: 자주 바뀔 경우, 불필요한 버전과 사본을 피해 중요한 것만 저장한다
-   자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮긴다

#### 장애 처리

-   로드밸런서 장애
    -   장애 발생 시 부 로드밸런서가 활성화되어 트래픽을 이어받야아 한다
    -   로드 밸런서끼리는 보통 heartbeat 신호를 주기적으로 보내어 상태를 모니터링 한다
-   블록 저장소 서버 장애
    -   다른 서버가 미완료 상태 또는 대기 상태인 작업을 이어받아야 한다
-   클라우드 저장소 장애
    -   S3 버킷은 여러 지역에 다중화할 수 있으므로, 한 지역 장애 발생 시 다른 지역에서 파일을 가져오면 된다
-   API 서버 장애
    -   무상태 서버이기 때문에, 로드밸런서에서 문제되는 서버로 요청을 보내지 않으면 된다
-   메타데이터 캐시 장애
    -   캐시 서버를 당중화한다
-   메타데이터 데이터베이스 장애
    -   주 데이터베이스 서버 장애: 부 DB 서버 가운데 하나를 주로 바꼬고, 부 DB 서버를 새로 추가한다
    -   부 데이터베이스 서버 장애: 다른 부 DB 서버가 읽기 연선을 처리하고, 그 동안 장애서버는 새로 교체된다
-   알림 서비스 장애
    -   롱 폴링 연결을 다시 접속시켜 복구하면 된다
-   오프라인 사용자 백업 큐 장애
    -   장애가 발생하면 구독 중인 클라이언트들은 백업 큐로 구독 관계를 재설정한다

## 4단계 마무리

블록 저장소 서버를 거치지 않고 파일을 클라우드 저장소에 직접 저장하 업로드 시간이 빨리질 수는 있다

-   하지만 분할, 압축, 암호화 로직을 클라이언트에 두어야 하기 때문에, 플랫폼 별로 따로 구현해야 한다
-   클라이언트가 해킹 당할 가능성이 있으므로 암호화 로직을 클라이언트 안에 두는 것은 적절하지 않다
    접속 상태를 관리하는 로직을 별도 서비스로 옮긴다면, 알림 서비스에서 분리하여 다른 서비스에서도 쉽게 활용할 수 있다
