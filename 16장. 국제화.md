## 16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원

국제 콘텐츠를 지원하기 위해, 서버는 클라이언트에게 각 문서의 문자와 언어를 알려줘서, 문서의 비트들을 올바른 문자들로 풀어내어 처리할 수 있게 해야한다

서브는 클라이언트에게 문서의 문자와 언어를 HTTP Content-Type charset 매개변수와 Content-Language 헤더를 통해 알려준다

클라이언트는 서버에게 어떤 언어를 사용할 수 있는지 말해주기 위해 Accept-Charset, Accept-Language 헤더를 보낸다

---

## 16.2 문자집합과 HTTP


### 16.2.1 차셋(Charset)은 글자를 비트로 변환하는 인코딩이다

HTTP 차셋 값은, 어떻게 콘텐츠 비트들을 특정 문자 체계의 글자들로 바꾸는지 말해주며, 각 태그들은 알고리즘을 명명한다

차셋 태그는 등록된 MIME 문자집합에 표준화되어 있고, IANA가 관리한다

ex) Content-Type: text/html; charset=iso-8859-6

UTF-8, iso-2022-jp 같은 문자 인코딩 들은 글자 당 비트 수가 일정하지 않은 가변길이 코드라 복잡하지만, 많은 글지로 이루어진 문자체계(중국어, 일본어 ,,,)를 지원한다


### 16.2.2 문자집합과 인코딩은 실제로 어떻게 동작하는가

비트를 문자로 변환하는 것은 크게 두 단계를 걸친다
1.  문서를 이루는 비트들은, 코딩된 특정 문자집합에서 각각 한 문자로 식별될 수 있는 문자 코드로 변환된다
2.  문자 코드는 코딩된 문자집합의 특정 요소를 선택하기 위해 사용된다


### 16.2.3 잘못된 차셋은 잘못된 글자들을 낳는다

만약 클라이언트가 잘못된 charset 매개변수를 사용한다면, 클라이언트는 깨진 글자를 보게 된다


### 16.2.4 표준화된 MIME 차셋 값

특정 문자 인코딩과 코딩된 특정 문자집합의 결합을 MIME 차셋이라고 부른다

HTTP은 표준화된 MIME 차셋 태그를 Content-Type과 Accept-Charset 헤더에 사용된다


### 16.2.5 Content-Type charset 헤더와 META 태그

웹 서버는 클라이언트에게 MIME 차셋태그를 charset 매개변수와 함께 Content-Type 헤더에 담아보낸다

만약 문자집합이 명시적으로 나열되어 있지 않다면, 수신자는 콘텐츠로부터 문자집합을 추측하기 시작한다 `<META HTTP-EQUIV=”Content-Type”>`

만약 추측하지 못했을 경우, iso-8859-1인 것으로 가정한다


### 16.2.6 Accept-Charset 헤더
대다수의 클라이언트는 모든 종류의 문자 코딩과 매핑 시스템을 지원하지는 않는다

그래서 HTTP 클라이언트는 서버에게 어떤 문자 체계를 지원하는지 `Accept-Charset` 요청 헤더를 통해 알려준다

알려준 헤더 값 중 어떤 것을 사용할 지는 서버에게 달려있다

`Accept-Charset` 요청 헤더에 대응하는 Content-Charset 은 없고, `Content-Type` 의 charset으로 사용한다

---

## 16.3 다중언어 문자 인코딩에 대한 지침


### 16.3.1 문자집합 용어

**문자**
- 알파벳 글자, 숫자, 구두점, 표의문자, 기호 등 글쓰기의 최소 단위
- 약식으로 유니코드라 불리는 국제 문자 세트 계획에 따라 표준화된 이름 집합이 개발되어 있다

**글리프(glyph)**
- 하나의 글자를 표현하기 위한 유일한 시각적 형태

**코딩된 문자(coded character)**
- 글자를 다룰 수 있도록 각 글자에 할당된 유일한 숫자

**코드 공간(coding space)**
- 문자 코드 값을 사용하려고 계획해둔 정수의 범위

**코드 너비(code width)**
- 문자 코드 값으로 사용하려고 계획해 둔 정수의 범위

**사용 가능한 문자집합(character repertoire)**
- 글자들에 대한 특정한 작업 집합(세상에 존재하는 모든 글자의 부분집합)

**코딩된 문자집합(coded charset set)**
- 실제 글자들에 수샂로 된 문자 코드를 대응시킨 것

**문자 인코딩 구조**
- 숫자로 된 문자 코드들을 콘텐츠 비트의 연속으로 인코딩하는 알고리즘
- 문자 인코딩 구조는 글자를 식별하기 위해 필요한 데이터의 양을 줄이거나, 전송 제약 회피, 중복 코딩된 문자집합을 통합할 때 사용할 수 있다


### 16.3.2 '차셋(charset)'은 형편없는 이름이다
MIME 차셋 태그는 문자집합을 의미하는 것이 아니다
MIME 차셋 값은 데이터 비트를 고유한 문자 코드로 매핑하는 알고리즘 이름이다 (문자 인코딩 구조 + 코딩된 문자집합)
하지만 용어가 혼란스러운데, 이미 문자 인코딩 구조와 코딩된 문자집합에 대한 출판된 표준이 있기 때문이다
따라서 표준 문서를 읽을 때 무엇이 정의되어 있는지 알수 있도록 주의해야 한다


### 16.3.3 문자
문자는 글꼴이나 스타일에 독립적이다
또한 같은 글자여도 어디에 위치하느냐에 따라 다른 모양을 갖는 표기 체계도 있다


### 16.3.4 글리프(glyphs), 연자(ligatures) 그리고 표현 형태
문자는 유일하고 추상화된 언어의 요소이다
글리프는 각 글자를 그리는 특정한 방법이다
또한 글리프는 더 멋지게 보이게 하기 위해 인접한 글자들이 부드럽게 이어지는 연자를 지원한다


### 16.3.5 코딩된 문자집합(Coded Charset Set)

***US-ASCII: 모든 문자집합의 어머니***
- 아스키는 1968년 ANSI 표준 X3.4로 표준화된 가장 유명한 코딩된 문자집합이다
- 오직 코드 값 0-127만 사용하기 때문에 7비트만 있으면 된다
- 다른 국제 변종과 구분하기 위해 'US-ASCII' 라는 이름이 더 선호된다

***iso-8859***
- 국제적인 글쓰기를 위해 필요한 글자들을 하이 비트를 이용해서 추가한, US-ASCII의 8비트 확대집합이다
- 추가 비트로는 모든 유럽 글자를 담기에 부족하여 지역에 따라 커스터마이징된 문자집합을 제공한다
- iso-8859-*
- Latin1로도 알려진 iso-8859-1은, HTML을 위한 기본 문자집합이다

***JIS X 0201***
- 아스키를 일본어 가타카나 반각문자를 더해 확장한 극단적으로 작은 문자집합이다
 - JIS X 0201은 보통 'JIS Roman'으로 불린다

***JIS X 0208과 JIS X 0212***
- 일본어는 여러 문자 체계로부터 온 수천 개의 글자를 담고 있다
- JIS X 0208 문자집합은 최초의 멀티바이트 일본어 문자집합으로 6879개의 문자를 정의했다
- JIS X 0212 문자집합은 6607개의 문자를 추가했다

***UCS***
- 국제 문자 세트(Universal Character Set)는 전 세계의 모든 글자를 하나의 코딩된 문자집합으로 통합하려 노력하는 세계적인 표준이다
- ISO 10646으로 정의된다
- 유니코드는 UCS 표준을 따르는 상업적인 컨소시엄이다
- 기본 집합은 50,000 글자만으로 이루어져 있지만, 수백만 개의 글자를 위한 코드 공간을 갖고 있다


### 16.3.6 문자 인코딩 구조
문자 인코딩 구조는 크게 세 종류로 분류할 수 있다

***고정폭***
- 각 코딩된 문자를 고정된 길이의 비트로 표현한다
- 빠르게 처리될 수 있지만, 공간을 낭비할 우려가 있다

***가변폭(비모달)***
- 다른 문자 코드 번호에 다른 길이의 비트를 사용한다
- 자주 사용하는 글자의 비트를 줄일 수 있고, 국제 문자는 여러 바이트를 사용하면서 호환성을 유지할 수 있다

***가변폭(모달)***
- 다른 모드로의 전화을 위해 'escape' 패턴을 사용한다
- 텍스트에서 중첩된 여러 가지 문자 집합 간의 전환을 위해 사용될 수 있다
- 처리하기 복잡하지만, 복잡한 표기 체계를 효과적으로 지원해준다


아래는 인코딩 구조이다

***8비트***
- 8비트 고정폭 아이덴티티 인코딩은 간단히 각 문자 코드를 그에 대응하는 8비트 값으로 인코딩한다
- 256개 문자의 코드 범위에 대한 문자집합만을 지원한다
- iso-8859 문자 집합군은 8비트 아이덴티티 인코딩을 사용한다

***UTF-8***
- 인기있는 UCS를 위해 설계된 문자 인코딩 구조이다
- UTF-8은 문자 코드의 값을 위해 비모달 가변길이 인코딩을 사용한다
- 첫 바이트의 선두 비트들은 인코딩된 문자의 길이를 바이트 단위로 나타내고, 이후 바이트들은 각각 6비트의 코드 값을 담는다

**iso-2022-jp**
- 일본어 인터넷 문서를 위해 널리 사용되는 인코딩이다
- 8비트 문자를 지원하지 않는 소프트웨어와의 문제점을 방지하기 위해 128보다 작은 값으로만 이루어진 가변길이 모달 인코딩이다
- 인코딩 콘텍스트는 네 가지의 미리 정의된 문자집합 중 하나로 설정된다

**euc-jp**
- 다른 인기있는 일본어 인코딩이다
- 유닉스 운영체제에서 아시아 문자들을 지원하기 위해 처음 개발되었다
- 가변 길이 인코딩이지만, 모달이 아니라는 차이가 있다

**euc-kr**
- 한글 인터넷 문서를 위해 널리 사용되는 가변길이 인코딩으로, KS X 1003, KS X 1001 두 가지 문자집합을 지원한다
- KS X 1001이 담고 있는 한글은 총 2,350자로, 턱없이 부족하기 때문에, 한글 채움 문자를 이용해 표현한다

---

## 16.4 언어 태그와 HTTP
언어태그는 언어에 이름을 붙이기 위한 짧고 표준화된 문자열이다


### 16.4.1 Content-Language 헤더

Content-Language 엔터티 헤더 필드는 어떤 언어 사용자를 대상으로 하고 있는지 서술한다

텍스트 문서만을 위한 것이 아니라, 오디오 클립, 동영상, 애플리케이션 등을 대상으로 할 수 있다

만약 콘텐츠가 여러 언어 사용자를 대상으로 하고 있다면, 여러 언어를 나열할 수 있다

하지만 여러 언어가 동시에 나열되었더라도, 언어 사용자들을 대상으로 하고 있음은 아니다


### 16.4.2 Accept-Language 헤더

HTTP는 언어 제약과 선호도를 웹 서버에 전달할 수 있게 해준다

만약 웹 서버가 어떤 자원에 대해 여러 언어로 된 버전을 갖고 있다면, 선호하는 언어로 된 컨텐츠를 줄 수 있다


### 16.4.3 언어 태그의 종류

언어태그는 다음을 표현하기 위해 사용될 수 있다
- 일반적인 언어의 종류
- 특정 국가의 언어
- 방언
- 지방어
- 그 외의, 다른 언어의 변형이 아닌 표준 언어
- 비표준 언어


### 16.4.4 서브태그

언어 태그는 하이픈으로 분리된 하나 이상의 서브 태그로 이루어져 있다
- 첫 번째 서브태그는 주 서브태그라 불리며, 표준화되어 있다
- 두 번째 서브태그는 선택적이고 자신만의 이름 표준을 따른다
- 세 번째부터의 서브 태그는 등록되어 있지 않다


### 16.4.5 대소문자의 구분 및 표현

모든 태그는 대소문자가 구분되지 않지만, 관용적으로 언어는 소문자, 국가는 대문자를 사용한다


### 16.4.6 IANA 언어 태그 등록

첫 번째와 두 번째 언어 서브태그의 값은 여러 가지 표준 문서와 그것들을 관리하는 조직에 의해 정의된다

만약 언어 태그가 국가와 언어 값으 조합이면, 굳이 등록되지 않아도 무방하다

IANA에 등록되어야 하는 경우는, 표준 국가와 언어 값으로 구성될 수 없는 언어태그들만 존재한다


### 16.4.7 첫 번째 서브태그: 이름공간

첫 번째 서브태그는 보통 ISO 639 표준 언어 집합에서 선택된 표준화된 언어 토큰이다

첫 번째 서브태그의 규칙은 다음과 같다
- 두 글자라면, ISO 639와 639-1 표준의 언어 코드다
- 세 글자라면, ISO 639-2 표준과 확장에 열거된 언어 코드다
- 글자 'i'라면, 언어 태그는 틀림없이 IANA에 등록된 것이다
- 글자 'x'라면, 언어 태그는 특정 개인, 집단 전용의 비표준 확장 서브태그다


### 16.4.8 두 번째 서브태그: 이름공간

두 번째 서브태그는 보통 ISO 3166 국가 코드와 지역 표준 집합에서 선택된 표준화된 국가토큰이다

두 번째 서브태그의 규칙은 다음과 같다
- 두 글자라면, ISO 3166에 정의된 국가/지역이다
- 3-8 글자라면, IANA에 등록된 것이다
- 한 글자라면, 뭔가 잘못된 것이다


### 16.4.9 나머지 서브태그: 이름공간

세 번째와 그 이후의 서브태그에 대해서는, 8자 이하의 알파벳과 숫자로 이루어져야 한다는 것외에 규칙은 없다


### 16.4.10 선호 언어 설정하기

웹 브라우저 프로필에서 선호 언어를 설정할 수 있다

---

## 16.5 국제화된 URI

오늘날 URI는 국제화를 그다지 지원하지 않으며, US-ASCII의 부분집합으로 구성되어 있다


### 16.5.1 국제적 가독성 vs 의미 있는 문자들

URI 설계자들은 전 세게 모두가 URI를 통해 다른 사람들과 공유할 수 있으면서, 쉽게 기억하기를 바랬다

그러기 위해 매우 제한된 공통 문자집합을 선택했으며, 전 세계 대부분의 소프트웨어와 키보드에서 지원한다

불행히도 문자집합에는 제한이 있기 때문에, URI는 비영어권 사람들도 쉽게 기억하도록 만들지는 못했다

URI 저자들은 리소스 식별자의 가독성과 공유 가능성의 보장이 더 중요하다고 판단했다

따라서 ASCII 문자들의 제한된 집합으로 이루어진 URI를 갖게 되었다


### 16.5.2 URI에서 사용될 수 있는 문자들

URI에서 사용할 수 있는 US-ASCII 문자들의 부분집합은 예약된 문자들, 예약되지 않은 문자들, 이스케이프 문자들로 나뉜다

예약되지 않은 문자들은 URI의 어떤 구성요소에서든 일반적으로 사용될 수 있다

예약된 문자들은 URI에서 특별한 의미를 가지며, 일반적으로 사용될 수 없다


### 16.5.3 이스케이핑과 역이스케이핑(unescaping)

URI 이스케이프는 예약된 문자나 다른 지원하지 않는 글자들을 URI에 삽입할 수 있는 방법을 제공한다

이스케이프는 퍼셋트 글자(%) 하나와 뒤이은 16진수 글자 둘로 이루어진 세글자 문자열이다

URI를 해석할 때, 이스케이핑된 코드 바이트들은 원래의 ASCII 코드 바이트로 변환된다

내부적으로 HTTP 애플리케이션은 URI를 데이터가 필요할 때만 언이스케이핑 해야한다

또한 결코 URI에서 두 번 언이스케이평 되지 않도록 해야 한다

한 번 더 하게 되면 퍼센트 기호 뒤에 있는 문자들이 이스케이프의 일부인 것처럼 처리되어 데이터 손실을 유발할 수 있다


### 16.5.4 국제 문자들을 이스케이핑 하기

이스케이프 값들은 US-ASCII 코드의 범위에 있어야 함을 주의해야 한다

웹 서버가 국제 문자를 포함한 파일 이름을 부호화하기 위해 이스케이핑을 오용할 수 있다

그럴 경우 어떤 애플리케이션에서는 문제를 유발할 수 있다


### 16.5.5 URI에서의 모달 전환

몇몇 URI는 다른 문자집합의 글자를 표현하기 위해 ASCII 문자열을 사용한다

현재, URI는 그다지 국제화에 친화적이지 않으며 URI 이식성의 목표는 언어 유연성의 목표보다 중요했었다

하지만 당분간은 ASCII를 계속 사용해야 한다

---

## 16.6 기타 고려사항


### 16.6.1 헤더와 명세에 맞지 않는 데이터

HTTP 헤더는 반드시 US-ASCII 문자집합의 글자들로만 이루어져야 한다

그러나 모든 클라이언트와 서버가 이를 올바르게 구현한 것은 아니므로, 잘못된 문자를 받게 될 수 있다

많은 HTTP 애플리케이션은 글자들을 처리하기 위해 운영체제와 라이브러리 루틴을 사용한다

몇몇 상황에서는 해당 라이브러리들이 ASCII가 아닌 글자에 대해 문제가 생긴다

따라서 라이브러리 문서를 주의 깊게 생각해야 한다


### 16.6.2 날짜

HTTP 명세는 올바른 GMT 날짜 형식을 명확히 정의하고 있지만 모든 웹 서버와 클라이언트가 규칙을 따르고 있지 않는다

HTTP 애플리케이션은 명세에 맞지 않는 날짜를 관대하게 받아들이고, 받아들이면서 충돌을 일으키면 안된다

하지만 처리할 수 없는 경우에 대해, 보수적으로 다루어야 한다


### 16.6.3 도메인 이름

국제화 문자를 포함하는 도메인 이름을 '국제화 도메인 이름'이라고 하는데, 대부분의 웹 브라우저가 퓨니코드(punycode)를 이용해 지원한다

퓨니코드는 유니코드 문자열을 호스트 명에서 사용 가능한 문자만으로 이루어진 문자열로 변환하는 방법이다

웹 브라우저들은 해당 기법을 이용해 다국어로 된 도메인 이름을 알파벳과 숫자 등으로 된 이름으로 변환한다
