## 2.1 코드를 신속하게 읽기

-   처음 프로그래밍을 배울 때는 문제를 어떻게 풀어낼지, 그리고 어떻게 구현할지에 대해 관심을 가지고 훈련한다
-   하지만 코드를 읽는 것은 다양한 목적을 가지고 읽으며, 특정 정보를 찾는 과정을 거친다
    -   새로운 기능에 추가할 부분
    -   수정한 코드 중 버그가 있을만한 곳
    -   특정 메서드의 구현 방식
    -   ...
-   만약 빠르게 찾을 수 있다면, 코드를 다시 찾아보는 과정이 줄어들게 된다

#### 두뇌에서 무슨일이 일어나는가?

```Java
public class InsertionSort {
	public static void main(String[] args) {
		int[] array = {45, 12, 85, 32, 89, 39, 69, 44, 42, 1, 6, 8};
		int temp;
		for (int i = 1; i < array.length; i++) {
			for (int j = i; j < 0; j--) {
				if (array[j] < array[j - 1]) {
					temp = array[j];
					array[j] = array[j - 1];
					array[j - 1] = temp;
				}
			}
		}
		for (int i = 0 ; i < array.length; i++) {
			System.out.println(array[i]);
		}
	}
}
```

-   위의 코드를 읽고 3분 후에 그대로 작성하면 무슨 일이 일어날까 -> STM, LTM이 사용된다
    -   STM에서는 `temp` 나, 배열에 대한 for 루프를 실행하는 것
    -   LTM에서는 `for(i = 1; i < length; i++)` 와 같은 for 루트 문법
    -   자바 문법은 기본적으로 LTM이며, 삽입정렬을 이미 아는 경우 LTM으로부터 기억을 가져와 작성하는 부분도 있을 것이다

#### 재현한 코드 다시 살펴보기

```Java
public void execute(int x[]) {
	int b = x.length;

	for (int v = b / 2 - 1; v >= 0; v--)
		func(x, b, v);

	// 원소를 하나씩 추출한다
	for (int l = b - 1; l > 0; l--) {
		// 현재 값을 마지막으로 옮긴다
		int temp = x[0];
		x[0] = x[l];
		x[l] = temp;

		func(x, l, 0);
	}
}
```

-   위의 코드를 3분동안 분석하고, 다시 재현하면 어떻게 될까
    -   이전 삽입정렬 예제보다 더 어려웠을 것이다
    -   코드가 무슨일을 하는지 모르기 때문에 LTM에 저장된 지식을 활용할 수 없어진다
    -   `b`, `l` 과 같은 잘 쓰지도 않고, 의미추론이 되지 않는 이름을 사용하면서, 패턴을 찾고 기억하는게 어려워졌다

#### 생소한 코드를 읽는 것은 왜 어려운가?

-   STM 용량에 제한이 있기 때문
    -   읽거나 들은 정보를 30초 이내로만 저장한다
    -   이후에는 잊거나 LTM에 저장한다
-   STM은 또한 크기도 제약이 생긴다
    -   최근 연구에는 2 ~ 6개로 더 적다고 추정된다
    -   이를 위해 STM은 LTM과 협업하여 정보를 이해한다

## 2.2 기억의 크기 제한을 극복하기

#### 단위로 묶는 것의 위력

-   네덜란드 수학자 아드리안 더흐로트는 **청크**라는 개념을 처음 사용했다
-   위대한 체스 선수가 되는 것에 대한 실험
    -   체스판에 임의로 말을 위치시키고 몇 초간 보여준 뒤 다시 기억하게 시킨다
    -   체스 마스터 그룹이 비전문가들보다 훨씬 더 잘 기억해냈다
-   언뜻보면 STM 용량이 큰 사람들이 전문가가 되는 것이라는 판단을 할 수 있다
    -   하지만 똑같은 실험에 체스말이 실제 게임 내에서 일어날 수 없는 위치에 무작위로 둔다면
    -   두 그룹 모두 제대로 기억하지 못한다
    -   비전문가들은 STM에서 가져온 기억으로 위치를 하나씩 기억한다
    -   전문가 그룹은 LTM에서 가져온 기억으로 과거 경험과 연결시키거나 읽었던 내용과 연결시켰다
-   몇 개의 그룹으로 묶은 정보를 **청크**라고 불렀다
-   코드에서 청킹은
    -   특정 주제에 대해 많은 정보를 알고 기억하고 있다면 효율적으로 입력된 정보들을 묶는 것이 가능해진다
    -   LTM에 지식이 많을 수록 기억을 쉽게하는 것도 프로그래밍에 해당한다

#### 전문가들은 초보자보다 코드를 더 잘 기억한다

-   초, 중, 고급 프로그래머에게 30줄짜리 ALGOL 프로그램을 2분간 파악하고 기억하는 실험
    -   실제 코드와 무작위로 줄을 섞은 코드
-   실제 코드는 숙련된 프로그래머가 더 잘 기억
-   섞어놓은 코드는 각 그룹이 별 차이 없음
-   다른 프로그래밍 언어를 잘 아는 전문가도 LTM에 저장되지 않은 낯선 문법, 키워드, 구조 등을 기억하는데에 어려움을 겪는다

## 2.3 읽는 것보다 보는 것이 더 많다

-   정보는 STM에 도달하기 전에 감각 기억 공간 영역을 통과한다
-   시각, 청각 등의 정보가 해당 영역에 잠시 저장된다
-   이론적으로는 코드에 대해 STM이 처리하는 것보다 시각을 통해 더 많은 정보를 저장하는 것이 가능하다는 것이다

#### 기억하는 대상이 중요한 것이 아니고 기억하는 방식이 중요하다

-   코드를 읽고 재현할 때에 본인의 기억에 의존한 코드를 보면 스스로 무엇을 잘못이해했는지 진단할 수 있다
-   하지만 '무엇'뿐만 아니라 코드를 어떤 '순서'로 기억했는지 파악하는 것도 자가 진단에 도움이 된다
-   `IF`, `TRUE`, `END` 등과 같은 ALGOL 언어 키워드를 기억하도록 교육 받을 때
    -   초보는 `TRUE IS REAL THEN FALSE` 같이 문장으로 만들어 기억한다
    -   숙련자는 `TRUE FALSE`, `IF THEN ELSE` 를 묶어서 기억한다 (이미 개념적인 지식이 있기 때문)

#### 청크로 묶을 수 있는 코드를 작성하는 방법

-   디자인 패턴 사용
    -   디자인 패턴이 사용된 코드를 유지 보수 할 때, 해당 패턴을 알고 있다면 빠르게 수정
    -   디자인 패턴이 사용되지 않은 코드를 유지 보수 할 때, 큰 차이 없음
    -   따라서 유지보수를 위해 디자인 패턴을 따르는 코드를 작성하면, 이후에 청킹 능력이 향상되어 빠르게 수정할 수 있다
-   주석문 쓰기
    -   코드 내에 주석이 있으면 코드를 읽는 시간이 오래걸린다고들 한다 -> 개발자들도 결국 읽는다는 것
    -   주석이 있으면 새로운 팀원이 코드를 쉽게 읽는 데에 도움이 된다
    -   적절한 수준의 주석문은 코드를 청크 단위로 쪼개는데에 오히려 도움이 된다

#### 청킹 연습

-   경험이 많은 사람이 결국 더 많은 것을 기억한다
-   경험이 아니라 의도적으로 코드 청킹 연습을 하는 것이 좋다
-   코드를 기억해내는 것을 훈련하는 것이 도움이 된다
