## 4.1  복잡한 코드를 이해하기 어려운 이유

#### 작업 기억 공간과 STM의 차이
- STM: 정보를 저장 (2 ~ 6개)
- 작업 기억 공간: 정보를 처리 (문제에 적용된 STM)
- 전화번호는 STM에서, 사칙 연산은 작업 기억 공간 활용
- STM 한도 초과가 되면, 인지 부하라고 말한다
- 작업 기억 공간에 너무 많은 요소들이 있어, 청크 단위로 나뉘지 않은 문제를 풀 때에는 과부하 상태가 된다고 한다

#### 프로그래밍과 관련한 인지 부하의 종류
- 부하의 종류
| 부하 종류   | 설명                                                                                                       |
| ----------- | ---------------------------------------------------------------------------------------------------------- |
| 내재적 부하 | 문제 자체가 얼마나 복잡한지. 피타고라스 정의를 이용해 빗변을 구하는 경우, 정리 자체의 복잡성이 내재적 부하 |
| 외재적 부하 | 외부적 요인에 의해 문제에 추가된 것. 삼각형의 각 변에 숫자를 넣을 경우                                     |
| 본유적 부하 | 생각을 LTM에서 저장하는 과정에서 일어나는 부하                                                             |


## 4.2 인지 부하를 줄이기 위한 기법

#### 리펙토링
- 외부적으로 제공하는 기능을 유지하고, 코드의 내부 구조를 개선하는 것
- 대개의 경우 리팩터링은 코드의 유지 보수를 쉽게 하기 위한 목적
- delocalized 코드는 가독성이 더 나빠져, 작업 기억 공간에 어려움을 줄 수 있다
- 가독성이 높은 코드로 전환하는 **인지적 리팩토링**은, 개발자를 위한 리팩토링이다
- 동시에 메서드 정의하지 않고 **인라인 메서드**를 사용하면, 가독성은 높아져도, 유지보수성이 높아진다

#### 생소한 언어 구성 요소를 다른 것으로 대치하기
- 언어 구성요소가 생소할 경우, 자신이 이해할 수 있는 문법으로 연습한다
- 이해하고 나면, 다시 원상복구 하는 방식을 써볼 수 있다

#### 플래시카드에 코드 동의어 추가
- 앞면에 삼항 연산자나 람다 개념을 활용한 코드를 적고
- 뒷면에 전통적인 방식의 코드를 적는 식으로 할 수 있다


## 4.3 작업 기억 공간에 부하가 오면 쓸 수 있는 기억 보조 수단
- 복잡한 코드 구조가 작업 기억 공간에 과부하를 유발하게 된다
  1. 코드의 어디를 파악해야 하는지 모를 때, 필요 이상의 코드를 읽게 되는 경우
  2. 코드가 밀접하게 연결되어 있는 경우, 어느 부분을 읽어야 하는지 판단을 위해 두뇌가 병렬 작업을 수행하는 경우

#### 의존 그래프 생성
1. 모든 변수를 원으로 표시한다
2. 비슷한 변수를 연결한다
3. 모든 메서드나 함수 호출을 원으로 표시한다
4. 메서드나 함수 호출을 정의와 연결한다
5. 클래스의 모든 인스턴스를 원으로 표시한다
6. 클래스와 그 클래스의 인스턴스를 연결한다

#### 상태표 사용
- 계산이 많은 코드의 어려움은 처리 능력 부족과 연관이 있다
- 따라서 변수 값 변경에 대한 상태표를 만들 수 있다
1. 모든 변수를 나열한다
2. 테이블을 만들고 각 열에 하나의 변수를 기입한다
3. 코드의 실행 단계마다 행을 만든다
4. 코드를 각 단계별로 실행하고 그 단계에서 변수들의 값을 해당하는 열과 행에 적는다



