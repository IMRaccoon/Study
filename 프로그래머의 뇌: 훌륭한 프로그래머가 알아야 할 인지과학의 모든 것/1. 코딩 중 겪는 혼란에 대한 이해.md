## 1.1 코드가 초래하는 세가지 종류의 혼란

ex. 주어진 숫자 n을 이진수로 바꾸는 작업

#### APL(A Programming Language)

> 특별히 수학적인 계산을 위해 만들어진 언어, 오늘날에는 거의 쓰이지 않는다.

```APL
2 2 2 2 2 T n
```

첫 번째 유형: 지식의 부족

-   T가 무엇인지 모르기 때문에 발생하는 혼란

#### Java

```Java
public class BinaryCalculator {
  public static void mian(Integer n) {
    System.out.println(Integer.toBinaryString(n));
  }
}
```

두 번째 유형: 정보의 부족

-   `toBinaryString` 메서드 내부가 어떻게 동작하는지 모를때 발생하는 혼란
-   메서드 이름으로부터 유추는 가능하지만 구체적으로 어떤 일을 수행하는지 이해하려면 메서드 내부를 살펴봐야 한다 (메서드 정보 부족)

#### 베이직 언어

```BASIC
1 LET N2 = ABS(INT(N));
2 LET B$ = ""
3 FOR N1 = N2 To 0 STEP 0
4   LET N2 = INT(N1 / 2)
5   LET B$ = STR$(N1 - N2 * 2) + B$
6   LET N1 = N2
7 NEXT N1
8 PRINT B$
```

세 번째 유형: 처리 능력의 부족

-   코드가 실행되는 각각의 단계들을 모두 이해하지 못해서 발생하는 혼란
-   변수에 임시로 저장되는 값을 모두 기억 불가

## 1.2 코딩에 영향을 주는 인지 과정

-   지식이 없다 -> 두뇌의 **장기 기억 공간**에 해당 내용이 없다 -> LTM(long-term memory) 문제
-   정보가 없다 -> **단기 기억 공간**에 해당 내용이 없다 -> STM(short-term memory) 문제
-   많은 정보를 처리하기 힘들다 -> **작업 기억 공간**과 관련되어 있다 -> 작업 기억 공간의 문제

#### Long-Term Memory와 프로그래밍

-   해당 기억들은 오래 보관되며, 여러 가지 다른 종류의 정보를 저장
-   컴퓨터 하드 디스크와 비슷
-   APL 프로그램이 LTM이라면
    -   T의 의미를 알고 있을 때에 코드가 읽히게 된다
    -   언어의 문법에 대한 지식이 중요하다
    -   T가 어떤 수의 값을 다른 진법의 수로 변환시켜주는 함수라는 것을 알면 간단해진다

#### Short-Term Memory와 프로그래밍

-   들어오는 정보를 잠시 보관하며, 크기 제한이 있다 (최대 12개 ?!)
-   Java 프로그램이 STM이라면
    -   `toBinaryString()` 이 변환하는 결과가 무엇인지 확인한다
    -   함수가 하는 일을 이해하고, 기억에서 지워버린다
    -   내부를 알 수 없다는 것에 대한 혼란은 LTM에 대한 역할이 추가로 필요로 한다
-   `mian`을 `main`으로 읽은 이유는?
    -   두뇌가 함수명을 미리 가정한다
    -   읽을 때는 STM에 저장(`mian`)되지만 LTM에 저장되어 있는 이름(`main`)으로 인식하게 된다
-   일시적으로 값을 저장하는 캐시나 메인 메모리와 비슷하다

#### 작업 기억 공간과 프로그래밍

-   STM, LTM은 기억장치와 가깝고, 실제 사고를 하는 곳은 작업 기억 공간(두뇌의 프로세서)에서 일어난다
-   베이직 프로그래밍에서의 과정
    -   `LET`, `EXIT` 등과 같은 키워드를 기억해낸다 -> LTM
    -   `B$` 는 빈 문자열로 시작된다 -> STM
    -   머릿속으로 따라가면서 코드를 컴파일하고 실행하는 과정 -> 작업 기억 공간에서 진행
    -   복잡해서 적고 싶은 상황 -> 작업 공간이 꽉차서 정보처리에 어려움이 생김

## 1.3 인지 과정들의 상호작용

-   결국 사고할 때에는 세가지 인지 과정이 모두 어느정도 활성화 된다
-   예를 들어 버그 리포트를 받았을 경우
    -   시각, 청각 등을 통해 두뇌로 입력
    -   전에 작성했던 코드를 읽고, 분석 -> STM에 저장되면서 LTM에서 구현했던 내용들을 가져옴
    -   LTM에 저장되어 있던 유사한 버그 해결방법이나 개인적으로 해결했던 방법 등이 작업 기억 공간으로 들어와 문제에 대해 고민하게 됨
